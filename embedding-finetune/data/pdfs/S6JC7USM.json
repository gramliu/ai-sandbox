{
  "key": "S6JC7USM",
  "url": "http://arxiv.org/pdf/2310.03714",
  "metadata": {
    "title": "DSPy: Compiling Declarative Language Model Calls into Self-Improving\n  Pipelines",
    "abstract": "  The ML community is rapidly exploring techniques for prompting language\nmodels (LMs) and for stacking them into pipelines that solve complex tasks.\nUnfortunately, existing LM pipelines are typically implemented using hard-coded\n\"prompt templates\", i.e. lengthy strings discovered via trial and error. Toward\na more systematic approach for developing and optimizing LM pipelines, we\nintroduce DSPy, a programming model that abstracts LM pipelines as text\ntransformation graphs, i.e. imperative computational graphs where LMs are\ninvoked through declarative modules. DSPy modules are parameterized, meaning\nthey can learn (by creating and collecting demonstrations) how to apply\ncompositions of prompting, finetuning, augmentation, and reasoning techniques.\nWe design a compiler that will optimize any DSPy pipeline to maximize a given\nmetric. We conduct two case studies, showing that succinct DSPy programs can\nexpress and optimize sophisticated LM pipelines that reason about math word\nproblems, tackle multi-hop retrieval, answer complex questions, and control\nagent loops. Within minutes of compiling, a few lines of DSPy allow GPT-3.5 and\nllama2-13b-chat to self-bootstrap pipelines that outperform standard few-shot\nprompting (generally by over 25% and 65%, respectively) and pipelines with\nexpert-created demonstrations (by up to 5-46% and 16-40%, respectively). On top\nof that, DSPy programs compiled to open and relatively small LMs like\n770M-parameter T5 and llama2-13b-chat are competitive with approaches that rely\non expert-written prompt chains for proprietary GPT-3.5. DSPy is available at\nhttps://github.com/stanfordnlp/dspy\n",
    "published": "2023-10-05T17:37:25Z"
  },
  "text": [
    "Preprint\nDSPY:COMPILINGDECLARATIVELANGUAGE\nMODELCALLS INTOSELF-IMPROVINGPIPELINES\nOmar Khattab,\n1\nArnav Singhvi,\n2\nParidhi Maheshwari,\n4\nZhiyuan Zhang,\n1\nKeshav Santhanam,\n1\nSri Vardhamanan,\n6\nSaiful Haq,\n6\nAshutosh Sharma,\n6\nThomas T. Joshi,\n7\nHanna Moazam,\n8\nHeather Miller,\n3,9\nMatei Zaharia,\n2\nChristopher Potts\n1\n1\nStanford University,\n2\nUC Berkeley,\n3\nCarnegie Mellon University,\n4\nAmazon Alexa AI,\n5\nDashworks Technologies, Inc.,\n6\nIIT Bombay,\n7\nCalera Capital,\n8\nMicrosoft,\n9\nTwo Sigma Investments\nokhattab@cs.stanford.edu\nABSTRACT\nThe ML community is rapidly exploring techniques for prompting language mod-\nels  (LMs)  and  for  stacking  them  into  pipelines  that  solve  complex  tasks.   Un-\nfortunately,  existing  LM  pipelines  are  typically  implemented  using  hard-coded\n“prompt templates”, i.e. lengthy strings discovered via trial and error.  Toward a\nmore systematic approach for developing and optimizing LM pipelines, we intro-\nduce DSPy, a programming model that abstracts LM pipelines astext transforma-\ntion graphs, i.e.  imperative computation graphs where LMs are invoked through\ndeclarativemodules.  DSPy modules areparameterized, meaning they can learn\n(by creating and collecting demonstrations) how to apply compositions of prompt-\ning, finetuning, augmentation, and reasoning techniques.  We design a compiler\nthat will optimize any DSPy pipeline to maximize a given metric.  We conduct\ntwo case studies, showing that succinct DSPy programs can express and optimize\nsophisticated LM pipelines that reason about math word problems, tackle multi-\nhop retrieval, answer complex questions, and control agent loops. Within minutes\nof compiling, a few lines of DSPy allowGPT-3.5andllama2-13b-chatto self-\nbootstrap  pipelines  that  outperform  standard  few-shot  prompting  (generally  by\nover 25% and 65%,  respectively) and pipelines with expert-created demonstra-\ntions (by up to 5–46% and 16–40%,  respectively).   On top of that,  DSPy pro-\ngrams compiled to open and relatively small LMs like 770M-parameterT5and\nllama2-13b-chatare  competitive  with  approaches  that  rely  on  expert-written\nprompt chains for proprietaryGPT-3.5.\nDSPy is available athttps://github.com/stanfordnlp/dspy.\n1INTRODUCTION\nLanguage models (LMs) are enabling researchers to build NLP systems at higher levels of abstrac-\ntion and with lower data requirements than ever before (Bommasani et al., 2021). This is fueling an\nexploding space of “prompting” techniques—and lightweight finetuning techniques—foradapting\nLMs to new tasks (Kojima et al., 2022), eliciting systematicreasoningfrom them (Wei et al., 2022;\nWang et al., 2022b), andaugmentingthem with retrieved sources (Guu et al., 2020; Lazaridou et al.,\n2022; Khattab et al., 2022) or with tools (Yao et al., 2022; Schick et al., 2023). Most of these tech-\nniques are explored in isolation, but interest has been growing in building multi-stagepipelinesand\nagentsthat decompose complex tasks into more manageable calls to LMs in an effort to improve\nperformance (Qi et al., 2019; Khattab et al., 2021a; Karpas et al., 2022; Dohan et al., 2022; Khot\net al., 2022; Khattab et al., 2022; Chen et al., 2022; Pourreza & Rafiei, 2023; Shinn et al., 2023).\nUnfortunately, LMs are known to be sensitive to how they are prompted for each task, and this is\nexacerbated in pipelines where multiple LM calls have tointeracteffectively.  As a result, the LM\n1\narXiv:2310.03714v1  [cs.CL]  5 Oct 2023",
    "Preprint\ncalls in existing LM pipelines and in popular developer frameworks are generally implemented using\nhard-coded ‘prompt templates’, that is, long strings of instructions and demonstrations that are hand\ncrafted through manual trial and error.  We argue that this approach, while pervasive, can be brittle\nand unscalable—conceptually akin to hand-tuning the weights for a classifier. A given string prompt\nmight not generalize to different pipelines or across different LMs, data domains, or even inputs.\nToward a more systematic approach to designing AI pipelines, we introduce theDSPyprogramming\nmodel.\n1\nDSPy pushes building new LM pipelines away from manipulating free-form strings and\ncloser toprogramming(composing modular operators to build text transformation graphs) where a\ncompiler automatically generates optimized LM invocation strategies and prompts from a program.\nWe draw inspiration from the consensus that emerged around neural network abstractions (Bergstra\net al., 2013), where (1) many general-purpose layers can be modularlycomposedin any complex\narchitecture and (2) the model weights can betrainedusing optimizers instead of being hand-tuned.\nTo this end, we propose theDSPy programming model(Sec 3).  We first translate string-based\nprompting techniques, including complex and task-dependent ones like Chain of Thought (Wei et al.,\n2022) and ReAct (Yao et al., 2022), into declarative modules that carrynatural-language typed sig-\nnatures. DSPy modules are task-adaptive components—akin to neural network layers—that abstract\nany particular text transformation, like answering a question or summarizing a paper.  We then pa-\nrameterize each module so that it canlearnits desired behavior by iteratively bootstrapping useful\ndemonstrations within the pipeline. Inspired directly by PyTorch abstractions (Paszke et al., 2019),\nDSPy modules are used via expressivedefine-by-runcomputational graphs. Pipelines are expressed\nby (1) declaring the modules needed and (2) using these modules in any logical control flow (e.g.,\nifstatements,forloops, exceptions, etc.) to logically connect the modules.\nWe then develop theDSPy compiler(Sec 4), which optimizes any DSPy program to improve quality\nor cost. The compiler inputs are the program, a few training inputs with optional labels, and a valida-\ntion metric.  The compiler simulates versions of the program on the inputs andbootstrapsexample\ntraces of each module for self-improvement,  using them to construct effective few-shot prompts\nor finetuning small LMs for steps of the pipeline.  Optimization in DSPy is highly modular:  it is\nconducted byteleprompters,\n2\nwhich are general-purpose optimization strategies that determine how\nthe modules should learn from data.  In this way, the compiler automatically maps the declarative\nmodules tohigh-qualitycompositions of prompting, finetuning, reasoning, and augmentation.\nProgramming models like DSPy could be assessed along many dimensions, but we focus on the role\nof expert-crafted prompts in shaping system performance. We are seeking to reduce or even remove\ntheir role through DSPy modules (e.g., versions of popular techniques like Chain of Thought) and\nteleprompters. We report on two expansive case studies: math word problems (GMS8K; Cobbe et al.\n2021) and multi-hop question answering (HotPotQA; Yang et al. 2018) with explorations of chain\nof thought, multi-chain reflection, multi-hop retrieval, retrieval-augmented question answering, and\nagent loops.  Our evaluations use a number of different compiling strategies effectively and show\nthat straightforward DSPy programs outperform systems using hand-crafted prompts,  while also\nallowing our programs to use much smaller and hence more efficient LMs effectively.\nOverall, this work proposes the first programming model that translates prompting techniques into\nparameterized  declarative  modules  and  introduces  an  effective  compiler  with  general  optimiza-\ntion strategies (teleprompters) to optimize arbitrary pipelines of these modules.  Our main contri-\nbutions  are  empirical  and  algorithmic:  with  DSPy,  we  have  found  that  we  can  implement  very\nshort programs that can bootstrap self-improving multi-stage NLP systems using LMs as small as\nllama2-13b-chatandT5-Large(770M parameters).   Without hand-crafted prompts and within\nminutes to tens of minutes of compiling, compositions of DSPy modules can raise the quality of\nsimple programs from 33% to 82% (Sec 6) and from 32% to 46% (Sec 7) forGPT-3.5and, simi-\nlarly, from 9% to 47% (Sec 6) and from 22% to 41% (Sec 7) forllama2-13b-chat.\n1\nDSPy  is  pronounceddee-ess-pie.   It’s  the  second  iteration  of  our  earlier  Demonstrate–Search–Predict\nframework (DSP; Khattab et al. 2022). This paper introduces the key concepts in DSPy. For more extensive and\nup-to-date documentation of the framework, we refer readers tohttps://github.com/stanfordnlp/dspy.\n2\nWe derive the nametele-prompters from the notion of abstracting and automating the task of prompting,\nin particular, such that it happensat a distance, without manual intervention.\n2",
    "Preprint\n2RELATEDWORK\nThis work is inspired by the role that Torch (Collobert et al., 2002), Theano (Bergstra et al., 2010;\n2011; Al-Rfou et al., 2016), Chainer (Tokui et al., 2015), and others played in the development in\ndeep learning by providing powerful abstractions. A similar transformation is emerging with higher-\nlevel pipelines of LMs, and we are seeking to offer a solid conceptual framework and programming\nabstractions for what we callfoundation model programming.  We draw on differentiable program-\nming (Wang et al., 2018) but applied to LM calls rather than neural networks, and borrow syntactic\nelements from PyTorch (Paszke et al., 2019).\nIn-context learning (McCann et al. 2018; Radford et al. 2018; Brown et al. 2020) is a key mechanism\nfor foundation model programming.   A growing body of work has revealed that,  especially with\ninstruction tuning (Ouyang et al., 2022), we can elicit sophisticated behavior via prompting (Wei\net al., 2022; Wang et al., 2022b; Press et al., 2022; Yao et al., 2022; Khot et al., 2022; Madaan et al.,\n2023).   Similarly,  forms of weak supervision that would normally require task-specific (Khattab\net al., 2021a;b) or hand-built (Ratner et al., 2016; Hancock et al., 2018) heuristics are now done by\nLMs (Wang et al., 2022b; Zelikman et al., 2022; Zhang et al., 2022; Shao et al., 2023).\nIn-context learning methods now routinely invoke tools, leading to LM pipelines that use retrieval\nmodels (Chen et al., 2017; Lewis et al., 2020; Guu et al., 2020; Lazaridou et al., 2022; Izacard et al.,\n2022), multimodal foundation models, and more traditional tools like APIs (Nakano et al., 2021)\nand calculators.  A number of toolkits have been developed to facilitate this, including LangChain\n(Chase, 2022),  Semantic Kernel (Microsoft, 2023),  LlamaIndex (Liu, 2022),  and many other re-\ntrieval  and  agent  libraries.   These  toolkits  provide  pre-packaged  chains  and  agents  that  connect\nLMs with numerous accessible tools.  However, they suffer from the pervasive prompt engineering\nchallenges we address in DSPy:  they express task-specific behavior through hand-written prompt\ntemplates (for detailed discussion, see Appendix B).\nResearchers are starting to apply discrete optimization and RL to find effective prompts, generally\nfor a single logical LM call (Guo et al., 2023; Pryzant et al., 2023; Huang et al., 2022; Yang et al.,\n2023).   DSPy seeks to generalize this space:  it offers a rich framework for optimizingarbitrary\npipelinesfromhigh-level declarative signatures, by bootstrapping high-qualitymulti-stage demon-\nstrationswith constraints.  In this framework, DSPy teleprompters may apply optimization using\nmodel selection techniques like cross-validation or, in principle, with sophisticated techniques in-\nvolving RL and LM feedback (Hu et al., 2023; Zhao et al., 2023a; Shinn et al., 2023) or learned or\nBayesian hyperparameter optimization methods (Bergstra et al., 2013; Akiba et al., 2019).\nThe present paper seeks to motivate DSPy as a programming model and to report new empirical\nfindings from applying the DSPy compiler.  This is inspired by formative work by Bergstra et al.\n(2010; 2013), Paszke et al. (2019), and Wolf et al. (2020), who support their respective programming\nmodels with a mix of benchmark numbers and some qualitative measures. For the current paper, we\nfocus on showing that DSPy and its compiler allow us to build outstanding LM systems without\nhand-crafted prompt strings, but instead from truly modular units, and that this opens up doors for\nsystematically exploring a rich design space at a very high programmatic level of abstraction.\n3THEDSPYPROGRAMMINGMODEL\nWe present DSPy, which treats LMs as abstract devices for text generation,\n3\nand optimizes their us-\nage in arbitrary computational graphs. DSPy programs are expressed in Python: each program takes\nthe task input (e.g., a question to answer or a paper to summarize) and returns the output (e.g., an\nanswer or a summary) after a series of steps. DSPy contributes three abstractions toward automatic\noptimization: signatures, modules, and teleprompters. Signatures abstract the input/output behavior\nof a module; modules replace existing hand-prompting techniques and can be composed in arbitrary\npipelines; and teleprompters optimize all modules in the pipeline to maximize a metric.\n3\nWe assume access to one or more LMs, which consume a prompt string and return text completions. This\nmay be a promptable LM capable of in-context learning (e.g., GPT-3.5 or Llama2-7b) or a smaller finetuneable\nLM (e.g., T5-base). An LM may be selected as the default; operations will use it unless configured otherwise.\n3",
    "Preprint\n3.1NATURALLANGUAGESIGNATURES CAN ABSTRACT PROMPTING&FINETUNING\nInstead of free-form string prompts, DSPy programs use natural languagesignaturesto assign work\nto the LM. A DSPy signature isnatural-language typeddeclaration of a function: a short declarative\nspec that tells DSPywhata text transformation needs to do (e.g., “consume questions and return\nanswers”), rather thanhowa specific LM should be prompted to implement that behavior.  More\nformally, a DSPy signature is a tuple ofinput fieldsandoutput fields(and an optionalinstruction).\nA field consists offield nameand optional metadata.\n4\nIn typical usage, the roles of fields are inferred\nby DSPy as a function of field names. For instance, the DSPy compiler will use in-context learning\nto interpretquestiondifferently fromanswerand will iteratively refine its usage of these fields.\nSignatures offer two benefits over prompts: they can be compiled into self-improving and pipeline-\nadaptive prompts or finetunes. This is primarily done by bootstrapping (Sec 4) useful demonstrating\nexamples for each signature.  Additionally, they handle structured formatting and parsing logic to\nreduce (or, ideally, avoid) brittle string manipulation in user programs.\nIn practice, DSPy signatures can be expressed with a shorthand notation likequestion -> answer,\nso that line 1 in the following is a complete DSPy program for a basic question-answering system\n(with line 2 illustrating usage and line 3 the response when GPT-3.5 is the LM):\n1qa = dspy.Predict(\"question  -> answer\")\n2qa(question=\"Where  is  Guaran\n ́\nı spoken?\")\n3# Out: Prediction(answer=’Guaran\n ́\nı is  spoken  mainly  in  South  America.’)\nIn the shorthand notation, each field’s name indicates the semantic role that the input (or output)\nfield plays in the transformation.  DSPy will parse this notation and expand the field names into\nmeaningful instructions for the LM, so thatenglishdocument -> frenchtranslationwould\nprompt for English to French translation. When needed, DSPy offers more advanced programming\ninterfaces for expressing more explicit constraints on signatures (Appendix A).\n3.2PARAMETERIZED&TEMPLATEDMODULES CAN ABSTRACT PROMPTING TECHNIQUES\nAkin to type signatures in programming languages, DSPy signatures simply define an interface and\nprovide type-like hints on the expected behavior. To use a signature, we must declare amodulewith\nthat signature, like we instantiated aPredictmodule above. A module declaration like this returns\nafunctionhaving that signature.\nThePredictModuleThe core module for working with signatures in DSPy isPredict(simplified\npseudocode in Appendix D.1). Internally,Predictstores the supplied signature, an optional LM to\nuse (initiallyNone, but otherwise overrides the default LM for this module), and a list of demon-\nstrations for prompting (initially empty). Like layers in PyTorch, the instantiated module behaves as\na callable function: it takes in keyword arguments corresponding to the signature input fields (e.g.,\nquestion), formats a prompt to implement the signature and includes the appropriate demonstra-\ntions, calls the LM, and parses the output fields. WhenPredictdetects it’s being used incompile\nmode, it will also internally track input/output traces to assist the teleprompter at bootstrapping the\ndemonstrations.\nOther Built-in ModulesDSPy modules translate prompting techniques into modular functions that\nsupport any signature, contrasting with the standard approach of prompting LMs with task-specific\ndetails (e.g., hand-written few-shot examples). To this end, DSPy includes a number of more sophis-\nticated modules likeChainOfThought,ProgramOfThought,MultiChainComparison, andReAct.\n5\nThese can all be used interchangeably to implement a DSPy signature. For instance, simply chang-\n4\nString descriptions of the task and the fields are also optional and usually omitted. Fields can carry optional\nfieldprefixanddescription. By default, fields are assumed to hold free-form strings; we are actively exploring\noptionaldata typeas a way to specify constraints on valid values (e.g.,boolorint) and more gracefully handle\nformatting and parsing logic, though this feature is not core to DSPy at the time of writing.\n5\nThese modules generalize prompting techniques from the literature,  respectively,  by Wei et al. (2022),\nChen et al. (2022), Yoran et al. (2023), and Yao et al. (2022) and, in doing so, generalize the ideas on zero-shot\nprompting and rationale self-generation from Kojima et al. (2022), Zelikman et al. (2022), Zhang et al. (2022),\nand Huang et al. (2022) to parameterized modules that can bootstrap arbitrary multi-stage pipelines.\n4",
    "Preprint\ningPredicttoChainOfThoughtin the above program leads to a system that thinks step by step\nbefore committing to its output field.\nImportantly, all of these modules are implemented in a few lines of code by expanding the user-\ndefined signature and callingPredictone or more times on new signatures as appropriate.   For\ninstance, we show a simplified implementation of the built-inChainOfThoughtbelow.\n1class  ChainOfThought(dspy.Module):\n2def  __init__(self , signature):\n3# Modify  signature  from  ‘*inputs  -> *outputs ‘ to  ‘*inputs  -> rationale , *outputs ‘.\n4rationale_field = dspy.OutputField(prefix=\"Reasoning: Let’s think  step by step.\")\n5signature = dspy.Signature(signature).prepend_output_field(rationale_field)\n6\n7# Declare a sub -module  with  the  modified  signature.\n8self.predict = dspy.Predict(signature)\n9\n10def  forward(self , ** kwargs):\n11# Just  forward  the  inputs  to the sub -module.\n12return  self.predict (** kwargs)\nThis is a fully-fledged module capable of learning effective few-shot prompting for any LM or task.\nWe contrast that with Appendix C, which copies long reasoning prompts hand-written by sources\nranging from recent research to popular prompting libraries.\nParameterizationUniquely, DSPyparameterizesthese prompting techniques.  To understand this\nparameterization,  observe that any LM call seeking to implement a particular signature needs to\nspecifyparametersthat include:  (1) the specific LM to call (Chen et al., 2023), (2) the prompt in-\nstructions (Yang et al., 2023) and the string prefix of each signature field and, most importantly, (3)\nthe demonstrations used as few-shot prompts (for frozen LMs) or as training data (for finetuning).\nWe focus primarily on automatically generating and selecting useful demonstrations.  In our case\nstudies, we find that bootstrapping good demonstrations gives us a powerful way to teach sophisti-\ncated pipelines of LMs new behaviors systematically.\nToolsDSPy programs may use tools, which are modules that execute computation. We support re-\ntrieval models through adspy.Retrievemodule. At the time of writing, DSPy has built-in support\nfor ColBERTv2, Pyserini, and Pinecone retrievers, and we have explored experimentaldspy.SQL\nfor executing SQL queries anddspy.PythonInterpreterfor executing Python code in a sandbox.\nProgramsDSPy modules can be composed in arbitrary pipelines in a define-by-run interface.  In-\nspired directly by PyTorch and Chainer, one first declares the modules needed at initialization, allow-\ning DSPy to keep track of them for optimization, and then one expresses the pipeline with arbitrary\ncode that calls the modules in aforwardmethod.  As a simple illustration, we offer the following\nsimple but complete retrieval-augmented generation (RAG) system.\n1class  RAG(dspy.Module):\n2def  __init__(self , num_passages =3):\n3# ‘Retrieve ‘ will  use  the  user’s default  retrieval  settings  unless  overriden.\n4self.retrieve = dspy.Retrieve(k=num_passages)\n5# ‘ChainOfThought ‘ with  signature  that  generates  answers  given  retrieval & question.\n6self.generate_answer = dspy.ChainOfThought(\"context , question  -> answer\")\n7\n8def  forward(self , question):\n9context = self.retrieve(question).passages\n10return  self.generate_answer(context=context , question=question)\nTo highlight modularity, we useChainOfThoughtas a drop-in replacement of the basicPredict.\nOne can now simply writeRAG()(\"Where is Guaran\n ́\nı spoken?\")to use it.  Notice that, if we\nuse a signature\"context, question -> searchquery\", we get a system that generates search\nqueries rather than answers.\n3.3TELEPROMPTERS CAN  AUTOMATE PROMPTING FOR  ARBITRARY PIPELINES\nWhen compiling a DSPy program, we generally invoke ateleprompter, which is an optimizer that\ntakes the program, a training set, and a metric—and returns a new optimized program.  Different\nteleprompters (Sec 4) apply different strategies for optimization.\n5",
    "Preprint\nIn DSPy, training sets may besmall, potentially a handful of examples, though larger data enables\nmore powerful optimization. Training examples may beincomplete, i.e., onlyinputvalues are nec-\nessary.  Labels for the pipeline steps are not required, unless they need to be used in the metric.  In\npractice, we typically assume labels only for (at most) the program’s final output, not the intermedi-\nate steps.  This label-efficiency is critical for modularity: building a new pipeline in DSPy requires\nsimplyrecompilingthe new pipeline’s code, not annotating data specific to the new pipeline.\nMetrics can be simple notions like exact match (EM) or F1, but they can be entire DSPy programs\nthat  balance  multiple  concerns.   For  example,  we  may  compile  theRAGmodule  above  against  a\ndataset of question–answer pairsqa\ntrainsetand the metric EM. The goal of optimization here is\nto effectively bootstrap few-shot demonstrations. The following code achieves this:\n1# Small  training  set  with  only  questions  and  final  answers.\n2qa_trainset = [dspy.Example(question=\"What is the  capital  of  France?\", answer=\"Paris\")]\n3\n4# The  teleprompter  will  bootstrap  missing  labels: reasoning  chains  and  retrieval  contexts.\n5teleprompter = dspy.BootstrapFewShot(metric=dspy.evaluate.answer_exact_match)\n6compiled_rag = teleprompter.compile(RAG(), trainset=qa_trainset)\nIn this example, theBootstrapFewShotteleprompter (Sec 4, Appendix E.1) simulatesRAGon the\ntraining example(s). It will collectdemonstrationsof each module (i.e., examples of its input–output\nbehavior) that collectively lead to valid output (i.e., respecting the signatures and the metric).\nIf one wanted to push the compiled program to be extractive given its retrieved contexts, one could\ndefine a custom metric to use in place ofdspy.evaluate.answer\nexactmatch:\n1def  answer_and_context_match(example , pred , trace=None):\n2answer_match = dspy.evaluate.answer_exact_match(example , pred)\n3\n4# Is the  prediction a substring  of some  passage?\n5context_match = any((pred.answer.lower () in c) for c in pred.context)\n6\n7return  answer_match  and  context_match\nNotice that  behavior like this might  be more accurately checked  by another DSPy program  that\nchecks for faithful grounding of answers. Such metrics are fully supported and encouraged in DSPy.\nTeleprompters can be composed by specifying ateacherprogram.  DSPy will sample demonstra-\ntions from this program for prompt optimization.  This composition can enable very rich pipelines,\nwhere expensive programs (e.g., complex expensive ensembles using large LMs) supervise cheap\nprograms (e.g., simple pipelines using smaller LMs). One may start withcompiledragfrom above\n(say, compiled to use a large Llama2-13b-chat LM) but now fine-tune Flan-T5-large to create an\nefficient program:\n1# Larger  set of  questions  with *no  labels *.  Labels  for  all  steps  will be  bootstrapped.\n2unlabeled_questions = [dspy.Example(question=\"What is the  capital  of  Germany?\"), ...]\n3\n4# As we  assumes  no answer , we use ‘answer_passage_match ‘ to  filter  ungrounded  answers.\n5finetuning_teleprompter = BootstrapFinetune(metric=dspy.evaluate.answer_passage_match)\n6\n7# We set ‘teacher=compiled_rag ‘ to  compose. Bootstrapping  will  now  use ‘compiled_rag ‘.\n8compiled_rag_via_finetune = finetuning_teleprompter.compile(RAG(), teacher=compiled_rag ,\ntrainset=unlabeled_questions , target=’google/flan -t5 -large ’)\n4THEDSPYCOMPILER\nA key source of DSPy’s expressive power is its ability to compile—or automatically optimize—any\nprogram in this programming model. Compiling relies on a teleprompter, which is an optimizer for\nDSPy programs that improves the quality (or cost) of modules via prompting or finetuning, which\nare unified in DSPy.  While DSPy does not enforce this when creating new teleprompters, typical\nteleprompters go through three stages.\nStage 1: Candidate GenerationThe compiler first (recursively) finds all uniquePredictmodules\n(predictors) in a program, including those nested under other modules.  Foreachunique predictor\np, the teleprompter may generate candidate values for the parameters ofp:  the instructions, field\ndescriptions, or—most importantly—demonstrations (i.e., example input–output pairs). In this iter-\n6",
    "Preprint\nation of DSPy, we focus on demonstrations and find that simple rejection-sampling-like approaches\ncan help bootstrap highly effective multi-stage systems.\nConsider the simplest non-trivial teleprompter in DSPy,BootstrapFewShot(simplified pseudocode\nin Appendix E.1).  This teleprompter will simulate a teacher program (or,  if unset,  the zero-shot\nversion of the program being compiled) on some training inputs, possibly one or more times with\na high temperature.  When running incompilemode, multi-stage traces are tracked transparently\nand in a thread-safe fashion throughout execution.  The program’s metric is used to filter for multi-\nstage traces that together help the pipeline pass the metric.  We thus obtain potential labels for all\nsignatures  in  the  program  by  throwing  away  the  bad  examples  and  using  the  good  examples  as\npotential demonstrations, though these design decisions are under user control.\nWhile LMs can be highly unreliable,  we find they can be rather efficient at searching the space\nof solutions for multi-stage designs.  A well-decomposed program can typically find at least a few\ntraining examples where the LM can pass the constraints enforced by the signatures and metrics,\nallowing us to bootstrap iteratively if needed.\nStage 2: Parameter OptimizationNow each parameter has a discrete set of candidates:  demon-\nstrations, instructions, etc.  Many hyperparameter tuning algorithms (e.g., random search or Tree-\nstructured Parzen Estimators as in HyperOpt (Bergstra et al., 2013) and Optuna (Akiba et al., 2019))\ncan be applied for selection among candidates.  We report simplified implementations of DSPy’s\nBootstrapFewShotWithRandomSearchandBootstrapFewShotWithOptunain Appendix E.2 and\nAppendix E.3.\nAnother type of optimization isfinetuningwithBootstrapFinetune, where the demonstrations are\nused to update the LM’s weights for each predictor. When this is applied, the LM parameter of each\nmodule is updated to the new LM weights.  Typically, we are optimizing average quality using the\nmetric with cross-validation over the training set or a validation set. This is applicable even with no\nlabels for any stages, depending on the nature of metric.\nStage 3: Higher-Order Program OptimizationA different type of optimization that the DSPy\ncompiler  supports  is  modifying  the  control  flow  of  the  program.   One  of  the  simplest  forms  of\nthese  is  ensembles,  which  we  use  in  the  case  studies  in  this  work.   An  ensemble  will  bootstrap\nmultiple copies of the same program, and then replace the program with a new one that runs them\nall in parallel andreducestheir predictions into one with a custom function (e.g., majority voting).\nIn future work,  this stage can easily accommodate techniques for more dynamic (i.e.,  test-time)\nbootstrapping as well as automatic backtracking-like logic.\n5GOALS OFEVALUATION\nProgramming frameworks can be evaluated along many dimensions:  computational efficiency, de-\nveloper efficiency, intuitiveness of the code and concepts, and so forth.  In this paper, we focus on\nperhaps the most pressing issue for current LM pipelines:  the role of hand-written,  task-specific\nprompts in achieving performant systems. Our evaluations seek to test the following hypotheses:\nH1With  DSPy,  we  can  replace  hand-crafted  prompt  strings  with  concise  and  well-defined\nmodules, without reducing quality or expressive power.\nH2Parameterizing  the  modules  and  treating  prompting  as  an  optimization  problem  makes\nDSPy better at adapting to different LMs, and it may outperform expert-written prompts.\nH3The resulting modularity makes it possible to more thoroughly explore complex pipelines\nthat have useful performance characteristics or that fit nuanced metrics.\nOur evaluation will explore these hypotheses using diverse task–program pairs. We hope this begins\na shift from underspecified questions like “how do different LMs compare on GSM8K” toward “how\nthey compare on GSM8K with program P when compiled with strategy S”, which is a well-defined\nand reproducible run.   Ultimately,  our goal is to reduce the role of artful prompt construction in\nmodern AI in favor of the development of new modular, composable programs and optimizers.\n7",
    "Preprint\nTable 1:  Results with in-context learning on GSM8K math word problems.  Each row represents\na separate pipeline:  the module in the Program column is compiled against the examples in the\nTraining set. The programs, compilers, and (small) training sets are defined in Section 6. Rows with\nensemblebuild on the immediately preceding row. Notably, all programs in this table are expressed\nby composing two to four DSPy modules and teleprompters. Compiling the correctmodules, instead\nof string prompts, improves different LMs from 4–20% accuracy to 49–88% accuracy.\nGPT-3.5Llama2-13b-chat\nProgramCompilationTrainingDevTestDevTest\nvanilla\nnonen/a24.025.27.09.4\nfewshot       trainset33.1–4.3–\nbootstrap     trainset44.0–28.0–\nbootstrap×2trainset64.761.737.336.5\n+ensemble     trainset62.761.939.034.6\nCoT\nnonen/a50.0–26.7–\nfewshot       trainset63.0–27.3–\nfewshot+humanCoT78.672.434.333.7\nbootstrap     trainset80.372.943.3–\n+ensemble     trainset88.381.643.7–\nreflection\nnonen/a65.0–36.7–\nfewshot       trainset71.7–36.3–\nbootstrap     trainset83.076.044.340.2\n+ensemble     trainset86.7–49.046.9\n6CASESTUDY: MATHWORDPROBLEMS\nWe evaluate on the popular GSM8K dataset with grade school math questions (Cobbe et al., 2021).\nWe sample 200 and 300 question–answer pairs from the official training set for training and develop-\nment, respectively. Our final evaluations use the 1.3k official test set examples. We report extensive\ncomparisons on the development set to avoid overfitting on test. Following prior work on GSM8K,\nwe evaluate the accuracy of the final numerical value that appears in the LM output.\nPrograms ConsideredFor this task,  we consider three simple DSPy programs:  a one-step Pre-\ndict module (vanilla), a two-step ChainOfThought module (CoT), and finally a multi-stage Com-\nparerOfThoughts module (ThoughtReflection). These are fully defined by the following code:\n1vanilla = dspy.Predict(\"question  -> answer\")   # GSM8K  Program  ‘vanilla ‘\n2\n3CoT = dspy.ChainOfThought(\"question  -> answer\")   # GSM8K  Program  ‘CoT ‘\n1class  ThoughtReflection(dspy.Module):\n2def  __init__(self , num_attempts):\n3self.predict = dspy.ChainOfThought(\"question  -> answer\", n=num_attempts)\n4self.compare = dspy.MultiChainComparison(’question  -> answer ’, M=num_attempts)\n5\n6def  forward(self , question):\n7completions = self.predict(question=question).completions\n8return  self.compare(question=question , completions=completions)\n9\n10reflection = ThoughtReflection(num_attempts =5) # GSM8K  Program  ‘reflection ‘\nInreflection, five reasoning chains are sampled from the LM (alongside their answers) and they\nare compared in parallel by a built-inMultiChainComparisonmodule, which generalizes Yoran\net al. (2023).  This generates a new answer taking into account the patterns from the five attempts.\nCritically, the modules used are all generic, none is specific math problems or particular LM.\nCompilingAs we discussed in Section 4,  DSPy programs can be compiled into new,  optimized\nprograms.   In  our  experiments,  we  evaluate  the  programs  zero-shot  (no  compiling)  as  well  as  a\nnumber of strategies for compiling. Our simplest compiler isLabeledFewShot:\n1fewshot = dspy.LabeledFewShot(k=8).compile(program , trainset=trainset)\nHere,programcan be any DSPy module. This simply samplesk=8random demonstrations from the\ntrainsetfor the fields common to the training examples and the signature(s), in this case,question\nandanswer, but not the reasoning for instance. We report the average of 3–5 runs (depending on the\nsetting) when applying such random sampling.\n8",
    "Preprint\nNext, we also consider bootstrapping few-shot examples with random search:\n1tp = BootstrapFewShotWithRandomSearch(metric=gsm8k_accuracy)\n2bootstrap = tp.compile(program , trainset=trainset , valset=devset)\nThis will generate demonstration chains for examples in the training set and optimize the selection\nof demonstrations (from this set) to self-improve the program’s modules. As the name indicates, this\nis done with random search, treating the selection of demonstrations as a parameter to optimize.\nNext, if desired, this bootstrapping process can be nested in DSPy.  In particular, we can use the\noptimizedbootstrapprogram  itself  to  further  bootstrap  another  program.   This  is  relevant,  for\nexample, whenever the original zero-shotprogramperforms relatively poorly.\n1bootstrap2 = tp.compile(program , teacher=bootstrap , trainset=trainset , valset=devset)\nAnd lastly, we considerensemblingthese bootstraps:\n1# A program  that  ensembles  the top -7  candidate  programs  from a bootstrapping  compiler  run\n(in  particular  ‘bootstrap ‘ or , when  applicable , ‘bootstrap2 ‘) with  majority  voting.\n2ensemble = Ensemble(reduce_fn=dspy.majority).compile(bootstrap.programs [:7])\nGSM8K  includes  human  reasoning  chains.   Above,trainsetdoes  not  include  these  reasoning\nchains. We also evaluate withtrainsethumanCoT, which extends the examples intrainsetwith\nthe human reasoning string.  These two datasets can be used interchangeably as the value for the\ntrainsetparameter above.  We note here that compiling generally runs on the order of minutes\n(or tens of minutes) as even the more expensive settings only require running the program a few\nthousand times (e.g., 10–20 trials over 150–300 validation examples) and they can occur in parallel.\nResultsOur results are summarized in Table 1, which includes dev results as well as our evaluation\nof promising representatives of each approach on the test set.  First, thevanillaprogram results\nshow thatGPT-3.5andllama2-13b-chatstruggle with math word problems when they have to\npredict the answers directly, that is, without using a reasoning chain first.  This is most pronounced\nin the absence of good demonstrations,  which can be seen in thenonecompilation setting (i.e.,\nzero-shot instruction) and thefewshotsetting (i.e., sampling random question–answer pairs).  In-\nterestingly, however,vanillais helped substantially by compiling withbootstrapand by iterating\nthis process intobootstrap×2. On inspecting the prompts bootstrapped (Appendix F), we see that\nthe prompt allows the LM to leverage the answer field for reasoning first, which is permitted as the\nmetric extracts the final numerical value for evaluation.\nNext, we consider theCoTprogram. While the expert human reasoning chains (+human\nCoT) provide\na large boost when available,  we can match or surpass this usingbootstrap,  substantiating our\nhypothesis  that  DSPy  can  cut  the  need  for  hand-crafted  prompts.   Beyond  this,  we  see  that  the\nreflectionprogram, while only a few lines longer than the others, is a clear winner, thoughCoTis\nquite effective withensemble.  Overall, thebootstrapcompilation procedure leads to large gains\nfor every program, across both LMs. Indeed, all programs in this table are expressed by composing\ntwo to four DSPy modules and teleprompters, and they reveal overall that—in the new paradigm\nprescribed  by  DSPy—it’s  composing  the  right  genericmodules,  rather  than  manipulating  string\nprompts, that improves different LMs from 4–20% accuracy to 49–88% accuracy.\nWe   can   informally   compare   with   the   following.Zhang   et   al.   (2022)   reports   48%   for\ntext-davinci-002,  which aligns closely with ourllama2-13b-chatresults,  and reports 59.4%\nwith codex when employing a manual CoT approach and 62.8% with an automatic CoT method.\nWang et al. (2022b) report 57% for CoT prompting withPaLM540-B, which becomes 74% upon\nadding self-consistency. The Llama2 authors (Touvron et al., 2023) presents 28.7% forllama2-13b,\n42.2% forllama2-34b, and 56.8% forllama2-70b. Intriguingly, our program with the 13b variant\nof the model is competitive with their 34b-based results even though we don’t use human reasoning\nchains in our program. Zhao et al. (2023b) reports 80.8% for CoT withgpt-3.5-turbofrom April\n2023.  The GPT-4 authors (OpenAI, 2023) reports that GPT-3.5 scores 57.1% and GPT-4 elevates\nthis to 92% but they note that GPT-4 was in fact pre-trained on a subset of GSM8K’s training set.\n9",
    "Preprint\n7CASESTUDY: COMPLEXQUESTIONANSWERING\nIn this case study, we explore the multi-hop question answering task with the HotPotQA (Yang et al.,\n2018) dataset in the open-domain “fullwiki” setting.  For retrieval, we use a search index of the of-\nficial Wikipedia 2017 “abstracts” dump of HotPotQA. Search is conducted by a ColBERTv2 (San-\nthanam et al., 2021) retriever. The HotPotQA test set is hidden, so we reserve the official validation\nset for our testing, and sample 1000 examples for that. We sub-divide the training set into 70%/30%\ntrain/validation splits.  In the training (and thus validation) split, we keep only examples marked as\n“hard” in the original dataset, which matches the designation of the official validation and test sets.\nFor training and for reporting development results, we sample 200 and 300 examples respectively.\nPrograms ConsideredOur simplest baseline is thevanillaprogram used in the previous case\nstudy on GSM8K (Sec 6); the\"question -> answer\"signature is universal enough that it will\nwork for this task (and many others) when compiled appropriately.\nOur baseline RAG program is the one given in Section 3.2 as a simple example of RAG with a\ndspy.ChainOfThoughtlayer.  We will see that this program does not excel at HotPotQA, and this\nmotivates us to evaluate two multi-hop programs.\nTo that end, we first test ReAct (Yao et al., 2022), a multi-step agent for tool use, which is imple-\nmented as a built-in module in DSPy. In the simplest case, a ReAct module for a particular signature\ncan be declared as follows in DSPy:\n1react = dspy.ReAct(\"question  -> answer\", tools =[dspy.Retrieve(k=1)], max_iters =5)\nWe also test the following custom program, which simulates the information flow in Baleen (Khattab\net al., 2021a) and IRRR (Qi et al., 2020) and has similarities to IRCoT (Trivedi et al., 2022).\n1class  BasicMultiHop(dspy.Module):\n2def  __init__(self , passages_per_hop):\n3self.retrieve = dspy.Retrieve(k=passages_per_hop)\n4self.generate_query = dspy.ChainOfThought(\"context , question  -> search_query\")\n5self.generate_answer = dspy.ChainOfThought(\"context , question  -> answer\")\n6\n7def  forward(self , question):\n8context = []\n9\n10for  hop in  range (2):\n11query = self.generate_query(context=context , question=question).search_query\n12context  += self.retrieve(query).passages\n13\n14return  self.generate_answer(context=context , question=question)\n15\n16multihop = BasicMultiHop(passages_per_hop =3)\nCompilingFor compilers, we continue to use the ones that we used for GSM8K (see Sec 6).  We\nalso consider two compositions of our teleprompters.  For ReAct, we consider bootstrapping with\nBootstrapFewShotWithRandomSearchstarting from an earlier bootstrap of the ReAct program.\nFor the simplemultihopprogram, we also consider fine-tuning withT5-Largestarting from the\nearlier bootstrap of that program.\n1multihop_t5 = dspy.BootstrapFinetune(metric=answer_exact_match).compile(program ,\nteacher=bootstrap , trainset=trainset , target=’t5 -large ’)\nResultsTable 2 summarizes our results. Compared with thevanillafew-shot prompting, a chain-\nof-thought and retrieval-augmented generation (CoTRAG) program can self-bootstrap in DSPy to\nincrease answer EM substantially. However, this relies entirely on the ColBERTv2 retriever to find\nrelevant passages directly from the original questions, limiting its passage recall.  This is tackled in\nthereactandmultihopprograms, which will generate queries for the retriever in multiple iterative\n“hops”.  Indeed, overall, a simplemultihopprogram performs the best, and in generalbootstrap\nagain proves to be very effective at raising its quality relative to itsfewshotvariant for both LMs.\nIn  particular,  we  can  see  thatbootstrap(and/orbootstrap×2)  can  outperform  bothfewshot\nprompting (formultihop) and expert human reasoning (forreact; adapted slightly from Yao et al.\n(2022) to our retrieval setting). Perhaps most importantly, we can makellama2-13b-chatcompet-\nitive with GPT-3.5 by simply compiling our programs.\nTo assess the finetuning capacity of DSPy,  we also evaluated the compilermultihop\nt5defined\nabove which produces aT5-Large(770M parameter) model.  This program scores 39.3% answer\nEM and 46.0% passage accuracy on the dev set, using only 200 labeled inputs and 800 unlabeled\n10",
    "Preprint\nTable 2: Results with in-context learning on HotPotQA multi-hop retrieval question answering. We\nreport answer exact match (Ans) and pair-retrieval accuracy (Psg).  Each row represents a separate\npipeline:  the module in the Program column is compiled against the examples in the Training set.\nThe programs, compilers, and (small) training sets are defined in the main text. For HotPotQA, we\nuse the training set (and not dev) directly for cross-validation.\n∗\nThe marked result is evaluated on\n50% of our test set due to cost.\nGPT-3.5Llama2-13b-chat\nProgramCompilerDevTestDevTest\nAnsPsgAnsPsgAnsPsgAnsPsg\nvanillafewshot34.3n/a31.5n/a27.5n/a21.8n/a\nCoTRAG\nfewshot36.436.029.834.434.536.028.034.4\nbootstrap42.336.0––38.336.032.934.4\nreact\nnone20.3–––20.0–––\n+humanr33.0–––28.3–––\nbootstrap31.0–––24.7–––\nbootstrap×239.0–––40.0–––\nmultihop\nfewshot36.938.331.240.834.732.031.330.8\nbootstrap48.7  47.0   39.6   43.8  42.0  48.3  36.4  43.5\nensemble54.7–45.6\n∗\n–50.0–41.0–\nquestions.   For  compiling,  we  use  a  teacher  program  consisting  of  an  ensemble  (union)  of  two\nmultihopwithllama2-13b-chat.  Considering its extremely small size and local availability, this\ncompiled program withT5-Largewould impose orders of magnitude lower costs for inference than\na proprietary LM like GPT-3.5.\nOur results may be pegged against the evaluation on HotPotQA in a number of recent papers, though\nthere is significant variation in evaluation methodology and test set samples across studies in this\nspace. Using CoT prompting, Si et al. (2022) achieve 25.2% EM. With a “recite-and-answer” tech-\nnique that uses PaLM-62B (Chowdhery et al., 2022) to recite evidence passages, Sun et al. (2022)\nachieve  26.5%  EM.  Wang  et  al.  (2022a)  achieve  33.8%  EM  and  44.6%  F1  when  applying  self-\nconsistency for PaLM-540B. Yao et al. (2022) achieve 27.4% EM using ReAct with PaLM-540B\nand 30.8 withtext-davinci-002,  with a tool giving it the ability for search using a Wikipedia\nAPI. They push their PaLM results to 35.1% EM by applying an additional CoT step with self-\nconsistency, which may resemble ourensembleapproach in the sense of aggregating multiple an-\nswers. Trivedi et al. (2022) reports 49% using a pipeline withcode-davinci-002LM on a sample\nof 500 HotPotQA questions.\n8CONCLUSION\nThis paper introduced DSPy, a new programming model for designing AI systems using pipelines\nof pretrained LMs and other tools.  We presented three new concepts introduced in this abstraction\n(DSPy signatures, modules, and teleprompters), and showed in two very different case studies that\nit supports rapid development of highly effective systems that use relatively small LMs.  We have\nmaintained open-source versions of this framework for close to a year. In this period, we have seen\nand created a large number of programs that were compiled to high-quality systems by DSPy, span-\nning tasks from information extraction to low-resource synthetic data generation.  In the interest of\nspace and to maintain reasonable scope in this paper, we leave reporting on such tasks under con-\ntrolled experimental conditions to future work. While in-context learning has proved transformative\nover the past 2–3 years of LM research, we argue that the true expressive power in this emerging\nparadigm is in building sophisticated text transformation graphs in which composable modules and\noptimizers (teleprompters) come together to leverage LMs in more systematic and reliable ways.\nACKNOWLEDGMENTS\nWe thank Josh Purtell for suggesting the apt name “text transformation graph” for the computational\ngraph abstraction of DSPy.   We thank Rick Battle,  Igor Kotenkov,  Lisa Li,  David Hall,  Ashwin\nParanjape, Chris Manning, Percy Liang, and many researchers, developers, and users for valuable\n11",
    "Preprint\ndiscussions and feedback.  We thank Giuseppe Attanasio for his public L\nA\nT\nE\nX GitHub-style Python\ncode formatting gist.\n6\nThis  work  was  partially  supported  by  IBM  as  a  founding  member  of  the  Stanford  Institute  for\nHuman-Centered Artificial Intelligence (HAI), Oracle, Virtusa, and Cigna Healthcare.  It was also\npartially supported by an HAI Azure compute grant. This research was supported in part by affiliate\nmembers and other supporters of the Stanford DAWN project–Facebook, Google, and VMware—as\nwell as the NSF under CAREER grant CNS-1651570.  Any opinions, findings, and conclusions or\nrecommendations expressed in this material are those of the authors and do not necessarily reflect\nthe views of the National Science Foundation. Omar Khattab is supported by the Apple Scholars in\nAI/ML fellowship.\n\\usepackage[pdftex]{graphicx} ...\n\\includegraphics[width=0.8\\linewidth]{myfile.pdf}\nREFERENCES\nTakuya  Akiba,  Shotaro  Sano,  Toshihiko  Yanase,  Takeru  Ohta,  and  Masanori  Koyama.   Optuna:\nA  next-generation  hyperparameter  optimization  framework.   InProceedings  of  the  25th  ACM\nSIGKDD international conference on knowledge discovery & data mining, pp. 2623–2631, 2019.\nRami  Al-Rfou,  Guillaume  Alain,  Amjad  Almahairi,  Christof  Angermueller,  Dzmitry  Bahdanau,\nNicolas  Ballas,  Fr\n ́\ned\n ́\neric  Bastien,  Justin  Bayer,  Anatoly  Belikov,  Alexander  Belopolsky,  et  al.\nTheano: A Python framework for fast computation of mathematical expressions.arXiv e-prints,\npp. arXiv–1605, 2016.\nJames Bergstra, Olivier Breuleux, Fr\n ́\ned\n ́\neric Bastien, Pascal Lamblin, Razvan Pascanu, Guillaume\nDesjardins, Joseph Turian, David Warde-Farley, and Yoshua Bengio.  Theano: A CPU and GPU\nmath compiler in Python. InProc. 9th python in science conf, volume 1, pp. 3–10, 2010.\nJames Bergstra, Fr\n ́\ned\n ́\neric Bastien, Olivier Breuleux, Pascal Lamblin, Razvan Pascanu, Olivier De-\nlalleau,  Guillaume  Desjardins,  David  Warde-Farley,  Ian  Goodfellow,  Arnaud  Bergeron,  et  al.\nTheano:  Deep learning on gpus with Python.  InNIPS 2011, BigLearning Workshop, Granada,\nSpain, volume 3. Citeseer, 2011.\nJames Bergstra, Daniel Yamins, and David Cox. Making a science of model search: Hyperparameter\noptimization in hundreds of dimensions for vision architectures.  InInternational conference on\nmachine learning, pp. 115–123. PMLR, 2013.\nRishi Bommasani, Drew A Hudson, Ehsan Adeli, Russ Altman, Simran Arora, Sydney von Arx,\nMichael S Bernstein, Jeannette Bohg, Antoine Bosselut, Emma Brunskill, et al.  On the opportu-\nnities and risks of foundation models.arXiv preprint arXiv:2108.07258, 2021.\nTom Brown, Benjamin Mann, Nick Ryder, Melanie Subbiah, Jared D Kaplan, Prafulla Dhariwal,\nArvind Neelakantan, Pranav Shyam, Girish Sastry, Amanda Askell, et al.  Language models are\nfew-shot learners.Advances in neural information processing systems, 33:1877–1901, 2020.\nHarrison  Chase.Hwchase17/langchain.2022.URLhttps://github.com/hwchase17/\nlangchain.\nDanqi  Chen,  Adam  Fisch,  Jason  Weston,  and  Antoine  Bordes.    Reading  Wikipedia  to  answer\nopen-domain  questions.    InProceedings  of  the  55th  Annual  Meeting  of  the  Association  for\nComputational Linguistics (Volume 1:  Long Papers), pp. 1870–1879, Vancouver, Canada, July\n2017. Association for Computational Linguistics.   doi:  10.18653/v1/P17-1171.   URLhttps:\n//aclanthology.org/P17-1171.\nLingjiao Chen, Matei Zaharia, and James Zou. Frugalgpt: How to use large language models while\nreducing cost and improving performance.arXiv preprint arXiv:2305.05176, 2023.\n6\nhttps://gist.github.com/g8a9/07c2be12ae02cfad4aa430d77dc940cb\n12",
    "Preprint\nWenhu Chen, Xueguang Ma, Xinyi Wang, and William W Cohen.  Program of thoughts prompt-\ning:  Disentangling computation from reasoning for numerical reasoning tasks.arXiv preprint\narXiv:2211.12588, 2022.\nAakanksha  Chowdhery,  Sharan  Narang,  Jacob  Devlin,  Maarten  Bosma,  Gaurav  Mishra,  Adam\nRoberts, Paul Barham, Hyung Won Chung, Charles Sutton, Sebastian Gehrmann, et al.   Palm:\nScaling language modeling with pathways.arXiv preprint arXiv:2204.02311, 2022.\nKarl  Cobbe,  Vineet  Kosaraju,  Mohammad  Bavarian,  Mark  Chen,  Heewoo  Jun,  Lukasz  Kaiser,\nMatthias  Plappert,  Jerry  Tworek,  Jacob  Hilton,  Reiichiro  Nakano,  et  al.   Training  verifiers  to\nsolve math word problems.arXiv preprint arXiv:2110.14168, 2021.\nRonan Collobert, Samy Bengio, and Johnny Mari\n ́\nethoz. Torch: a modular machine learning software\nlibrary. Technical report, Idiap, 2002.\nDavid Dohan, Winnie Xu, Aitor Lewkowycz, Jacob Austin, David Bieber, Raphael Gontijo Lopes,\nYuhuai Wu, Henryk Michalewski, Rif A Saurous, Jascha Sohl-Dickstein, et al.  Language model\ncascades.arXiv preprint arXiv:2207.10342, 2022.\nLuyu Gao, Zhuyun Dai, Panupong Pasupat, Anthony Chen, Arun Tejasvi Chaganty, Yicheng Fan,\nVincent Zhao, Ni Lao, Hongrae Lee, Da-Cheng Juan, et al.  Rarr: Researching and revising what\nlanguage models say, using language models.  InProceedings of the 61st Annual Meeting of the\nAssociation for Computational Linguistics (Volume 1: Long Papers), pp. 16477–16508, 2023a.\nLuyu Gao, Aman Madaan, Shuyan Zhou, Uri Alon, Pengfei Liu, Yiming Yang, Jamie Callan, and\nGraham Neubig.  Pal: Program-aided language models.  InInternational Conference on Machine\nLearning, pp. 10764–10799. PMLR, 2023b.\nQingyan Guo, Rui Wang, Junliang Guo, Bei Li, Kaitao Song, Xu Tan, Guoqing Liu, Jiang Bian,\nand Yujiu Yang. Connecting large language models with evolutionary algorithms yields powerful\nprompt optimizers.arXiv preprint arXiv:2309.08532, 2023.\nKelvin Guu, Kenton Lee, Zora Tung, Panupong Pasupat, and Ming-Wei Chang.  Realm: Retrieval-\naugmented language model pre-training.arXiv preprint arXiv:2002.08909, 2020.  URLhttps:\n//arxiv.org/abs/2002.08909.\nBraden Hancock, Paroma Varma, Stephanie Wang, Martin Bringmann, Percy Liang, and Christopher\nR\n ́\ne.  Training classifiers with natural language explanations.  InProceedings of the 56th Annual\nMeeting of the Association for Computational Linguistics (Volume 1:  Long Papers), pp. 1884–\n1895. Association for Computational Linguistics, 2018. URLhttp://aclweb.org/anthology/\nP18-1175.\nBin Hu, Chenyang Zhao, Pu Zhang, Zihao Zhou, Yuanhang Yang, Zenglin Xu, and Bin Liu.  En-\nabling intelligent interactions between an agent and an LLM: A reinforcement learning approach.\narXiv preprint arXiv:2306.03604, 2023. URLhttps://arxiv.org/abs/2306.03604.\nJiaxin Huang, Shixiang Shane Gu, Le Hou, Yuexin Wu, Xuezhi Wang, Hongkun Yu, and Jiawei\nHan. Large language models can self-improve.arXiv preprint arXiv:2210.11610, 2022.\nGautier Izacard, Patrick Lewis, Maria Lomeli, Lucas Hosseini, Fabio Petroni, Timo Schick, Jane\nDwivedi-Yu, Armand Joulin, Sebastian Riedel, and Edouard Grave.  Few-shot learning with re-\ntrieval augmented language models.arXiv preprint arXiv:2208.03299, 2022.\nEhud Karpas, Omri Abend, Yonatan Belinkov, Barak Lenz, Opher Lieber, Nir Ratner, Yoav Shoham,\nHofit Bata, Yoav Levine, Kevin Leyton-Brown, et al.  Mrkl systems: A modular, neuro-symbolic\narchitecture that combines large language models, external knowledge sources and discrete rea-\nsoning.arXiv preprint arXiv:2205.00445, 2022.\nOmar Khattab, Christopher Potts, and Matei Zaharia. Baleen: Robust Multi-Hop Reasoning at Scale\nvia Condensed Retrieval.  InThirty-Fifth Conference on Neural Information Processing Systems,\n2021a.\nOmar Khattab, Christopher Potts, and Matei Zaharia. Relevance-guided supervision for openqa with\nColBERT.Transactions of the Association for Computational Linguistics, 9:929–944, 2021b.\n13",
    "Preprint\nOmar  Khattab,  Keshav  Santhanam,  Xiang  Lisa  Li,  David  Hall,  Percy  Liang,  Christopher  Potts,\nand Matei Zaharia.  Demonstrate-search-predict:  Composing retrieval and language models for\nknowledge-intensive nlp.arXiv preprint arXiv:2212.14024, 2022.\nTushar Khot, Harsh Trivedi, Matthew Finlayson, Yao Fu, Kyle Richardson, Peter Clark, and Ashish\nSabharwal.   Decomposed  prompting:  A  modular  approach  for  solving  complex  tasks.arXiv\npreprint arXiv:2210.02406, 2022.\nTakeshi Kojima, Shixiang Shane Gu, Machel Reid, Yutaka Matsuo, and Yusuke Iwasawa.   Large\nlanguage models are zero-shot reasoners.arXiv preprint arXiv:2205.11916, 2022.\nAngeliki  Lazaridou,  Elena  Gribovskaya,  Wojciech  Stokowiec,  and  Nikolai  Grigorev.    Internet-\naugmented language models through few-shot prompting for open-domain question answering.\narXiv preprint arXiv:2203.05115, 2022.\nPatrick   Lewis,   Ethan   Perez,   Aleksandra   Piktus,   Fabio   Petroni,   Vladimir   Karpukhin,   Na-\nman   Goyal,   Heinrich   K\n ̈\nuttler,   Mike   Lewis,   Wen-tau   Yih,   Tim   Rockt\n ̈\naschel,   Sebastian\nRiedel,   and  Douwe  Kiela.Retrieval-augmented  generation  for  knowledge-intensive  nlp\ntasks.In  H.  Larochelle,  M.  Ranzato,  R.  Hadsell,  M.F.  Balcan,  and  H.  Lin  (eds.),Ad-\nvances  in  Neural  Information  Processing  Systems,  volume  33,  pp.  9459–9474.  Curran  Asso-\nciates, Inc., 2020. URLhttps://proceedings.neurips.cc/paper\nfiles/paper/2020/file/\n6b493230205f780e1bc26945df7481e5-Paper.pdf.\nJerry Liu. LlamaIndex, 11 2022. URLhttps://github.com/jerryjliu/llamaindex.\nAman Madaan,  Niket Tandon,  Prakhar Gupta,  Skyler Hallinan,  Luyu Gao,  Sarah Wiegreffe,  Uri\nAlon, Nouha Dziri, Shrimai Prabhumoye, Yiming Yang, et al.  Self-refine:  Iterative refinement\nwith self-feedback.arXiv preprint arXiv:2303.17651, 2023.\nBryan McCann, Nitish Shirish Keskar, Caiming Xiong, and Richard Socher.  The natural language\ndecathlon:  Multitask learning as question answering.   arXiv:1806.08730,  2018.   URLhttps:\n//arxiv.org/abs/1806.08730.\nMicrosoft. Semantic kernel. 2023. URLhttps://learn.microsoft.com/semantic-kernel/.\nReiichiro  Nakano,  Jacob  Hilton,  Suchir  Balaji,  Jeff  Wu,  Long  Ouyang,  Christina  Kim,  Christo-\npher  Hesse,  Shantanu  Jain,  Vineet  Kosaraju,  William  Saunders,  Xu  Jiang,  Karl  Cobbe,  Tyna\nEloundou, Gretchen Krueger, Kevin Button, Matthew Knight, Benjamin Chess, and John Schul-\nman.  WebGPT: Browser-assisted question-answering with human feedback, 2021.  URLhttps:\n//arxiv.org/abs/2112.09332.\nOpenAI. Gpt-4 technical report, 2023.\nLong Ouyang, Jeff Wu, Xu Jiang, Diogo Almeida, Carroll L Wainwright, Pamela Mishkin, Chong\nZhang, Sandhini Agarwal, Katarina Slama, Alex Ray, et al.  Training language models to follow\ninstructions with human feedback.arXiv preprint arXiv:2203.02155, 2022.\nAdam Paszke, Sam Gross, Francisco Massa, Adam Lerer, James Bradbury, Gregory Chanan, Trevor\nKilleen, Zeming Lin, Natalia Gimelshein, Luca Antiga, Alban Desmaison, Andreas Kopf, Edward\nYang,  Zachary DeVito,  Martin Raison,  Alykhan Tejani,  Sasank Chilamkurthy,  Benoit Steiner,\nLu Fang,  Junjie Bai,  and Soumith Chintala.   PyTorch:  An imperative style,  high-performance\ndeep learning library.   In H. Wallach,  H. Larochelle,  A. Beygelzimer,  F. d'Alch\n ́\ne-Buc,  E. Fox,\nand R. Garnett (eds.),Advances in Neural Information Processing Systems, volume 32. Curran\nAssociates, Inc., 2019.  URLhttps://proceedings.neurips.cc/paper\nfiles/paper/2019/\nfile/bdbca288fee7f92f2bfa9f7012727740-Paper.pdf.\nMohammadreza Pourreza and Davood Rafiei.  Din-sql: Decomposed in-context learning of text-to-\nsql with self-correction.arXiv preprint arXiv:2304.11015, 2023.\nOfir Press, Muru Zhang, Sewon Min, Ludwig Schmidt, Noah A Smith, and Mike Lewis. Measuring\nand narrowing the compositionality gap in language models.arXiv preprint arXiv:2210.03350,\n2022.\n14",
    "Preprint\nReid Pryzant, Dan Iter, Jerry Li, Yin Tat Lee, Chenguang Zhu, and Michael Zeng. Automatic prompt\noptimization with” gradient descent” and beam search.arXiv preprint arXiv:2305.03495, 2023.\nPeng Qi, Xiaowen Lin, Leo Mehr, Zijian Wang, and Christopher D. Manning.  Answering complex\nopen-domain  questions  through  iterative  query  generation.   InProceedings  of  the  2019  Con-\nference on Empirical Methods in Natural Language Processing and the 9th International Joint\nConference on Natural Language Processing (EMNLP-IJCNLP), pp. 2590–2602,  Hong Kong,\nChina,  2019.  Association  for  Computational  Linguistics.   doi:  10.18653/v1/D19-1261.   URL\nhttps://aclanthology.org/D19-1261.\nPeng Qi,  Haejun Lee,  Oghenetegiri Sido,  Christopher D Manning,  et al.   Retrieve,  rerank,  read,\nthen iterate: Answering open-domain questions of arbitrary complexity from text.arXiv preprint\narXiv:2010.12527, 2020. URLhttps://arxiv.org/abs/2010.12527.\nAlec Radford,  Karthik Narasimhan,  Tim Salimans,  and Ilya Sutskever.   Improving language un-\nderstanding by generative pre-training.  Ms, OpenAI, 2018.  URLhttps://openai.com/blog/\nlanguage-unsupervised/.\nAlexander  J  Ratner,  Christopher  M  De  Sa,  Sen  Wu,  Daniel  Selsam,  and  Christopher  R\n ́\ne.   Data\nprogramming:   Creating  large  training  sets,  quickly.In  D.  D.  Lee,  M.  Sugiyama,  U.  V.\nLuxburg, I. Guyon, and R. Garnett (eds.),Advances in Neural Information Processing Systems\n29,  pp.  3567–3575.  Curran  Associates,  Inc.,  2016.   URLhttps://papers.nips.cc/paper/\n6523-data-programming-creating-large-training-sets-quickly.\nKeshav Santhanam, Omar Khattab, Jon Saad-Falcon, Christopher Potts, and Matei Zaharia.  Col-\nBERTv2:   Effective  and  Efficient  Retrieval  via  Lightweight  Late  Interaction.arXiv  preprint\narXiv:2112.01488, 2021.\nTimo Schick, Jane Dwivedi-Yu, Roberto Dess\n`\nı, Roberta Raileanu, Maria Lomeli, Luke Zettlemoyer,\nNicola Cancedda, and Thomas Scialom.  Toolformer: Language models can teach themselves to\nuse tools.arXiv preprint arXiv:2302.04761, 2023.\nZhihong  Shao,  Yeyun  Gong,  Yelong  Shen,  Minlie  Huang,  Nan  Duan,  and  Weizhu  Chen.   Syn-\nthetic prompting: Generating chain-of-thought demonstrations for large language models.arXiv\npreprint arXiv:2302.00618, 2023.\nNoah Shinn, Beck Labash, and Ashwin Gopinath.  Reflexion:  an autonomous agent with dynamic\nmemory and self-reflection.arXiv preprint arXiv:2303.11366, 2023.\nChenglei Si, Zhe Gan, Zhengyuan Yang, Shuohang Wang, Jianfeng Wang, Jordan Boyd-Graber, and\nLijuan Wang. Prompting gpt-3 to be reliable.arXiv preprint arXiv:2210.09150, 2022.\nZhiqing Sun, Xuezhi Wang, Yi Tay, Yiming Yang, and Denny Zhou. Recitation-augmented language\nmodels.arXiv preprint arXiv:2210.01296, 2022.\nSeiya Tokui, Kenta Oono, Shohei Hido, and Justin Clayton. Chainer: a next-generation open source\nframework for deep learning.  InProceedings of workshop on machine learning systems (Learn-\ningSys) in the twenty-ninth annual conference on neural information processing systems (NIPS),\nvolume 5, pp. 1–6, 2015.\nHugo Touvron, Louis Martin, Kevin Stone, Peter Albert, Amjad Almahairi, Yasmine Babaei, Niko-\nlay Bashlykov, Soumya Batra, Prajjwal Bhargava, Shruti Bhosale, et al.  Llama 2: Open founda-\ntion and fine-tuned chat models.arXiv preprint arXiv:2307.09288, 2023.\nHarsh Trivedi,  Niranjan Balasubramanian,  Tushar Khot,  and Ashish Sabharwal.   Interleaving re-\ntrieval  with  chain-of-thought  reasoning  for  knowledge-intensive  multi-step  questions.arXiv\npreprint arXiv:2212.10509, 2022.\nFei  Wang,   James  Decker,   Xilun  Wu,   Gregory  Essertel,   and  Tiark  Rompf.Backpropaga-\ntion  with  callbacks:    Foundations  for  efficient  and  expressive  differentiable  programming.\nIn  S.  Bengio,   H.  Wallach,   H.  Larochelle,   K.  Grauman,   N.  Cesa-Bianchi,   and  R.  Gar-\nnett  (eds.),Advances  in  Neural  Information  Processing  Systems,  volume  31.  Curran  Asso-\nciates, Inc., 2018. URLhttps://proceedings.neurips.cc/paper\nfiles/paper/2018/file/\n34e157766f31db3d2099831d348a7933-Paper.pdf.\n15",
    "Preprint\nXuezhi  Wang,  Jason  Wei,  Dale  Schuurmans,  Quoc  Le,  Ed  Chi,  and  Denny  Zhou.    Rationale-\naugmented ensembles in language models.arXiv preprint arXiv:2207.00747, 2022a.\nXuezhi Wang, Jason Wei, Dale Schuurmans, Quoc Le, Ed Chi, and Denny Zhou.  Self-consistency\nimproves  chain  of  thought  reasoning  in  language  models.arXiv  preprint  arXiv:2203.11171,\n2022b.\nJason  Wei,  Xuezhi  Wang,  Dale  Schuurmans,  Maarten  Bosma,  Ed  Chi,  Quoc  Le,  and  Denny\nZhou.   Chain of thought prompting elicits reasoning in large language models.arXiv preprint\narXiv:2201.11903, 2022.\nThomas Wolf, Lysandre Debut, Victor Sanh, Julien Chaumond, Clement Delangue, Anthony Moi,\nPierric Cistac,  Tim Rault,  Remi Louf,  Morgan Funtowicz,  Joe Davison,  Sam Shleifer,  Patrick\nvon  Platen,  Clara  Ma,  Yacine  Jernite,  Julien  Plu,  Canwen  Xu,  Teven  Le  Scao,  Sylvain  Gug-\nger,  Mariama  Drame,  Quentin  Lhoest,  and  Alexander  Rush.    Transformers:   State-of-the-art\nnatural  language  processing.    InProceedings  of  the  2020  Conference  on  Empirical  Methods\nin  Natural  Language  Processing:   System  Demonstrations,  pp.  38–45,  Online,  2020.  Associ-\nation  for  Computational  Linguistics.    doi:   10.18653/v1/2020.emnlp-demos.6.    URLhttps:\n//aclanthology.org/2020.emnlp-demos.6.\nChengrun Yang,  Xuezhi Wang,  Yifeng Lu,  Hanxiao Liu,  Quoc V Le,  Denny Zhou,  and Xinyun\nChen. Large language models as optimizers.arXiv preprint arXiv:2309.03409, 2023.\nZhilin Yang, Peng Qi, Saizheng Zhang, Yoshua Bengio, William W Cohen, Ruslan Salakhutdinov,\nand Christopher D Manning.   Hotpotqa:  A dataset for diverse, explainable multi-hop question\nanswering.arXiv preprint arXiv:1809.09600, 2018.\nShunyu Yao, Jeffrey Zhao, Dian Yu, Nan Du, Izhak Shafran, Karthik Narasimhan, and Yuan Cao.\nReact: Synergizing reasoning and acting in language models.arXiv preprint arXiv:2210.03629,\n2022.\nOri Yoran, Tomer Wolfson, Ben Bogin, Uri Katz, Daniel Deutch, and Jonathan Berant.  Answering\nquestions by meta-reasoning over multiple chains of thought.arXiv preprint arXiv:2304.13007,\n2023.\nEric Zelikman, Yuhuai Wu, and Noah D Goodman.  Star: Bootstrapping reasoning with reasoning.\narXiv preprint arXiv:2203.14465, 2022.\nZhuosheng Zhang, Aston Zhang, Mu Li, and Alex Smola. Automatic chain of thought prompting in\nlarge language models.arXiv preprint arXiv:2210.03493, 2022.\nAndrew Zhao, Daniel Huang, Quentin Xu, Matthieu Lin, Yong-Jin Liu, and Gao Huang.  ExpeL:\nLLM agents are experiential learners.arXiv preprint arXiv:2308.10144, 2023a.   URLhttps:\n//arxiv.org/pdf/2308.10144.\nXu Zhao, Yuxi Xie, Kenji Kawaguchi, Junxian He, and Qizhe Xie. Automatic model selection with\nlarge language models for reasoning.arXiv preprint arXiv:2305.14333, 2023b.\n16",
    "Preprint\nAADVANCEDSIGNATURES\nWhen  more  control  is  desired,  one  can  express  signatures  as  Python  classes  to  provide  explicit\ninstructions of the transformation and describe the format or role of each field more directly.  For\ninstance, the following signature generates search queries using context and an optional question:\n1class  GenerateSearchQuery(dspy.Signature):\n2\"\"\" Write a simple  search  query  that  will  help  answer a complex  question.\"\"\"\n3\n4context = dspy.InputField(desc=\"may  contain  relevant  facts\")\n5question = dspy.InputField ()\n6query = dspy.OutputField(dtype=dspy.SearchQuery)\nUsing the above, we can specify a complete system for the generation of a synthetic IR dataset where\nthe queries are mediated by a question generated by the LM:\n1query_gen = dspy.Predict(GenerateSearchQuery)\n2query_gen(context=\"Language  typology\")\n3# Out: Prediction(question=’What  are  the  main  types  of  language  classification?’,\nquery=’\"language  classification\" OR \"language  typology\" -wikipedia ’)\nIf  questions  are  available,  they  can  be  supplied  as  shown:querygen(context=\"Language\ntypology\", question=\"What are the primary language families of South America?\").\nAs a work in progress feature, users can optionally specify the type of output fields asbool, int,\nfloat, list, ordictinstead of the default free-form string type, as incontexts, question ->\nanswerfound: bool.\nBCOMPARISON WITH EXISTING LIBRARIES LIKELANGCHAIN  AND\nLLAMAINDEX\nLangChain and LlamaIndex are perhaps the most popular library in the general space of prompting\nLMs.  These libraries have a different focus compared to DSPy and they suffer internally from the\nprompt engineering challenges that DSPy aims to resolve.  In particular, whereas the goal of DSPy\nis to tackle the fundamental challenges of prompt engineering for building new LM computational\ngraphs, LangChain and LlamaIndex generally help application developers who need pre-packaged\ncomponents and chains,  e.g.,  implementations of popular and reusable pipelines (e.g.,  particular\nagents and specific retrieval pipelines) and tools (e.g., connections to various databases and imple-\nmentations of long- and short-term memory for agents).\nThese off-the-shelf higher-level abstractions contrast with DSPy’s focus on introducing core com-\nposable  operators.   In  particular,  DSPy  introduces  signatures  (to  abstract  prompts),  modules  (to\nabstract prompting techniques), and teleprompters to act as optimizers for arbitrary imperative code\n(DSPy  programs)  that  chain  modules  together.   Its  goal  is  to  help  researchers  and  practitioners\nbuild new LM pipelines quickly and achieve very high quality through automatic compilation (self-\nimprovement) instead of manual prompt engineering.\nIn  contrast,  typical  existing  research  implementations  and  existing  libraries  like  LangChain  and\nLlamaIndex are implemented using manual prompt engineering, which is the key problem that DSPy\ntackles.   We  conducted  an  informal  study  to  highlight  this.   In  late  September  2023,  we  found\nthat the LangChain codebase contains 50 strings exceeding 1000 characters, which are generally\nprompts, compared to none at all in DSPy.  Indeed, a substantial number of LangChain’s Python\nfiles are singularly dedicated to task-related templating and prompt engineering with 12prompts.py\nfiles and and 42prompt.pyfiles.  DSPy, on the other hand, provides a structured framework that\nautomatically bootstraps prompts.  The library itself does not contain a single hand-written prompt\ndemonstration for any tasks at the time of writing, despite the very high quality with various LMs.\nTo review the typical forms of prompt engineering in existing libraries,  we consider the follow-\ning in LangChain.  The LangChain Program-Aided Language Model Gao et al. (2023a) chain pro-\ngram uses few-shot learning, leveraging a template that is 3982 characters long with 8 math word\nproblems (Prompt 2) and corresponding outputted programs as learning examples for the language\nmodel.  LangChain also contains a prompt for SQL query tasks foreachof the databases like Or-\nacle, GoogleSQL, DuckDB, Crate, and MySQL, with the average length of these prompts at 1058\ncharacters.  Other task areas such as QA with sources (Prompt B) and Graph\nQA also have signif-\n17",
    "Preprint\nicantly lengthy prompt templates, with averages of 1337 and 722 characters, respectively.  While\nexpert-written prompts can be useful, we believe that LM- and task-adaptive prompts bootstrapped\nautomatically can offer far more power (and are far more modular) than hard-coding a prompt per\ndatabase provider inside the code base.  The next appendix section contains a number of prompts\ncopied from related research papers and existing libraries.\nCSAMPLE LARGE PROMPTS\nThis section  highlights a  few popular  existing frameworks  that structure  prompts with  extensive\nprompt engineering templates. The primary objective is to capture how many words and characters\nare  used  for  such  large  multi-line  prompts  defined  for  tasks  or  tools  and  present  these  example\nprompts  retrieved  from  open-sourced  papers  and  repositories.   The  formatting  of  these  example\nprompts is adapted from Gao et al. (2023a).\nTask/Tool PromptSourceWordsCharacters\nPrompt 1: Text-evidence checkerGao et al. (2023a)8184964\nPrompt 2: Math word problems (PAL)LangChain & Gao et al. (2023b)5663957\nPrompt 3: ReActYao et al. (2022)5933889\nPrompt 4: Zero-shot ReActLangChain101600\nPrompt 5: QA with sourcesLangChain9926197\nPrompt 6: SQL MyScale queryingLangChain3432239\nPrompt 7: Relevant docs retrievalLlamaIndex129719\nPrompt 8: IRS chatbotLlamaIndex3892258\n18",
    "Preprint\n1    [web] I will check some things you said.\n2\n3    (1) You said: Your nose switches back and forth between nostrils. When you sleep, you switch about every 45 minutes. This\nis to prevent a buildup of mucus. It’s called the nasal cycle.\n4    I checked: How often do your nostrils switch?\n5    I found this article: Although we don’t usually notice it, during the nasal cycle one nostril becomes congested and thus\ncontributes less to airflow, while the other becomes decongested. On average, the congestion pattern switches about every\n2 hours, according to a small 2016 study published in the journal PLOS One.\n6    Your nose’s switching time is about every 2 hours, not 45 minutes.\n7    This disagrees with what you said.\n8\n9    (2) You said: The Little House books were written by Laura Ingalls Wilder. The books were published by HarperCollins.\n10    I checked: Who published the Little House books?\n11    I found this article: These are the books that started it all -- the stories that captured the hearts and imaginations of\nchildren and young adults worldwide. Written by Laura Ingalls Wilder and published by HarperCollins, these beloved books\nremain a favorite to this day.\n12    The Little House books were published by HarperCollins.\n13    This agrees with what you said.\n14\n15    (3) You said: The Stanford Prison Experiment was conducted in the basement of Jordan Hall, Stanford’s psychology building.\n16    I checked: Where was Stanford Prison Experiment conducted?\n17    I found this article: Carried out August 15-21, 1971 in the basement of Jordan Hall, the Stanford Prison Experiment set\nout to examine the psychological effects of authority and powerlessness in a prison environment.\n18    The Stanford Prison Experiment was conducted in Jordan Hall.\n19    This agrees with what you said.\n20\n21    (4) You said: Social work is a profession that is based in the philosophical tradition of humanism. It is an intellectual\ndiscipline that has its roots in the 1800s.\n22    I checked: When did social work have its roots?\n23    I found this article: The Emergence and Growth of the Social work Profession<br><br> Social work’s roots were planted in\nthe 1880s, when charity organization societies (COS) were created to organize municipal voluntary relief associations and\nsettlement houses were established.\n24    Social work has its roots in the 1880s, not 1800s.\n25    This disagrees with what you said.\n26\n27    (5) You said: The Havel-Hakimi algorithm is an algorithm for converting the adjacency matrix of a graph into its adjacency\nlist. It is named after Vaclav Havel and Samih Hakimi.\n28    I checked: What is the Havel-Hakimi algorithm?\n29    I found this article: The Havel-Hakimi algorithm constructs a special solution if a simple graph for the given degree\nsequence exists, or proves that one cannot find a positive answer. This construction is based on a recursive algorithm.\nThe algorithm was published by Havel (1955), and later by Hakimi (1962).\n30    Havel-Hakimi algorithm is for constructing a special solution if a simple graph for the given degree sequence exists, or\nproving that one cannot find a positive answer, not converting the adjacency matrix of a graph into its adjacency list.\n31    This disagrees with what you said.\n32\n33    (6) You said: \"Time of My Life\" is a song by American singer-songwriter Bill Medley from the soundtrack of the 1987 film\nDirty Dancing. The song was produced by Michael Lloyd.\n34    I checked: Who was the producer of \"(I’ve Had) The Time of My Life\"?\n35    I found this article: On September 8, 2010, the original demo of this song, along with a remix by producer Michael Lloyd,\nwas released as digital files in an effort to raise money for the Patrick Swayze Pancreas Cancer Resarch Foundation at\nStanford University.\n36    \"Time of My Life\" was produced by Michael Lloyd.\n37    This agrees with what you said.\n38\n39    (7) You said: Kelvin Hopins was suspended from the Labor Party because he had allegedly sexually harassed and behaved\ninappropriately towards a Labour Party activist, Ava Etemadzadeh.\n40    I checked: Why was Kelvin Hopins suspeneded from the Labor Party?\n41    I found this article: A former Labour MP has left the party before an inquiry into sexual harassment allegations against\nhim was able to be concluded, the party has confirmed. Kelvin Hopkins was accused in 2017 of inappropriate physical contact\nand was suspended by the Labour party pending an investigation.This agrees with what you said.\n42    Kelvin Hopins was suspended because he had allegedly sexually harassed and behaved inappropriately towards a Labour Party\nactivist, Ava Etemadzadeh.\n43    This agrees with what you said.\n44\n45    (8) You said: In the battles of Lexington and Concord, the British side was led by General Thomas Smith.\n46    I checked: Who led the British side in the battle of Lexington and Concord?\n47    I found this article: Interesting Facts about the Battles of Lexington and Concord. The British were led by Lieutenant\nColonel Francis Smith. There were 700 British regulars.\n48    The British side was led by Lieutenant Colonel Francis Smith, not General Thomas Hall.\n49    This disagrees with what you said.\n50\n51    (9) You said:{text}\n52    I checked:{query}\n53    I found this article:{evidence}\n54\nFigure 1:  Example few-shot prompt using a reasoning chain for agreement model that identifies\ninconsistencies between text and evidence (Gao et al., 2023a).\n19",
    "Preprint\n1    Q: Olivia has$23. She bought five bagels for$3 each. How much money does she have left?\n2\n3    # solution in Python:\n4\n5\n6    def solution():\n7        \"\"\"Olivia has$23. She bought five bagels for$3 each. How much money does she have left?\"\"\"\n8        moneyinitial = 23\n9        bagels = 5\n10        bagelcost = 3\n11        moneyspent = bagels * bagelcost\n12        moneyleft = moneyinitial - moneyspent\n13        result = moneyleft\n14        return result\n15\n16\n17\n18\n19\n20    Q: Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls did he\nhave at the end of wednesday?\n21\n22    # solution in Python:\n23\n24\n25    def solution():\n26        \"\"\"Michael had 58 golf balls. On tuesday, he lost 23 golf balls. On wednesday, he lost 2 more. How many golf balls\ndid he have at the end of wednesday?\"\"\"\n27        golfballsinitial = 58\n28        golfballslosttuesday = 23\n29        golfballslostwednesday = 2\n30        golfballsleft = golfballsinitial - golfballslosttuesday - golfballslostwednesday\n31        result = golfballsleft\n32        return result\n33\n34\n35\n36\n37\n38    Q: There were nine computers in the server room. Five more computers were installed each day, from monday to thursday.\nHow many computers are now in the server room?\n39\n40    # solution in Python:\n41\n42\n43    def solution():\n44        \"\"\"There were nine computers in the server room. Five more computers were installed each day, from monday to thursday.\nHow many computers are now in the server room?\"\"\"\n45        computersinitial = 9\n46        computersperday = 5\n47        numdays = 4\n48        computersadded = computersperday * numdays\n49        computerstotal = computersinitial + computersadded\n50        result = computerstotal\n51        return result\n52\n53\n54\n55\n56\n57    Q: Shawn has five toys. For Christmas, he got two toys each from his mom and dad. How many toys does he have now?\n58\n59    # solution in Python:\n60\n61\n62    def solution():\n63        \"\"\"Shawn has five toys. For Christmas, he got two toys each from his mom and dad. How many toys does he have now?\"\"\"\n64        toysinitial = 5\n65        momtoys = 2\n66        dadtoys = 2\n67        totalreceived = momtoys + dadtoys\n68        totaltoys = toysinitial + totalreceived\n69        result = totaltoys\n70        return result\n71\n72\n73\n74\n75\n76    Q: Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give to\nDenny?\n77\n78    # solution in Python:\n79\n80\n81\n20",
    "Preprint\n1\n2\n3\n4    def solution():\n5        \"\"\"Jason had 20 lollipops. He gave Denny some lollipops. Now Jason has 12 lollipops. How many lollipops did Jason give\nto Denny?\"\"\"\n6        jasonlollipopsinitial = 20\n7        jasonlollipopsafter = 12\n8        dennylollipops = jasonlollipopsinitial - jasonlollipopsafter\n9        result = dennylollipops\n10        return result\n11\n12\n13\n14\n15\n16    Q: Leah had 32 chocolates and her sister had 42. If they ate 35, how many pieces do they have left in total?\n17\n18    # solution in Python:\n19\n20    def solution():\n21        \"\"\"Leah had 32 chocolates and her sister had 42. If they ate 35, how many pieces do they have left in total?\"\"\"\n22        leahchocolates = 32\n23        sisterchocolates = 42\n24        totalchocolates = leahchocolates + sisterchocolates\n25        chocolateseaten = 35\n26        chocolatesleft = totalchocolates - chocolateseaten\n27        result = chocolatesleft\n28        return result\n29\n30\n31\n32\n33\n34    Q: If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?\n35\n36    # solution in Python:\n37\n38\n39    def solution():\n40        \"\"\"If there are 3 cars in the parking lot and 2 more cars arrive, how many cars are in the parking lot?\"\"\"\n41        carsinitial = 3\n42        carsarrived = 2\n43        totalcars = carsinitial + carsarrived\n44        result = totalcars\n45        return result\n46\n47\n48\n49\n50\n51    Q: There are 15 trees in the grove. Grove workers will plant trees in the grove today. After they are done, there will be\n21 trees. How many trees did the grove workers plant today?\n52\n53    # solution in Python:\n54\n55\n56    def solution():\n57        \"\"\"There are 15 trees in the grove. Grove workers will plant trees in the grove today. After they are done, there will\nbe 21 trees. How many trees did the grove workers plant today?\"\"\"\n58        treesinitial = 15\n59        treesafter = 21\n60        treesadded = treesafter - treesinitial\n61        result = treesadded\n62        return result\n63\n64\n65\n66\n67\n68    Q:{question}\n69\n70    # solution in Python:\nFigure 2: PAL example few-shot prompt for solving math questions by generating code.\n21",
    "Preprint\n1    Solve a question answering task with interleaving Thought, Action, Observation steps. Thought can reason about the current\nsituation, and Action can be three types:\n2    (1) Search[entity], which searches the exact entity on Wikipedia and returns the first paragraph if it exists. If not, it\nwill return some similar entities to search.\n3    (2) Lookup[keyword], which returns the next sentence containing keyword in the current passage.\n4    (3) Finish[answer], which returns the answer and finishes the task.\n5    Here are some examples.\n6    Question: What is the elevation range for the area that the eastern sector of the Colorado orogeny extends into?\n7    Action 1: Search[Colorado orogeny]\n8    Observation 1: The Colorado orogeny was an episode of mountain building (an orogeny) in Colorado and surrounding areas.\n9    Action 2: Lookup[eastern sector]\n10    Observation 2: (Result 1 / 1) The eastern sector extends into the High Plains and is called the Central Plains orogeny.\n11    Action 3: Search[High Plains]\n12    Observation 3: High Plains refers to one of two distinct land regions:\n13    Action 4: Search[High Plains (United States)]\n14    Observation 4: The High Plains are a subregion of the Great Plains. From east to west, the High Plains rise in elevation\nfrom around 1,800 to 7,000 ft (550 to 2,130 m).[3]\n15    Action 5: Finish[1,800 to 7,000 ft]\n16    Question: Musician and satirist Allie Goertz wrote a song about the \"The Simpsons\" character Milhouse, who Matt Groening\nnamed after who?\n17    Action 1: Search[Milhouse]\n18    Observation 1: Milhouse Mussolini Van Houten is a recurring character in the Fox animated television series The Simpsons\nvoiced by Pamela Hayden and created by Matt Groening.\n19    Action 2: Lookup[named after]\n20    Observation 2: (Result 1 / 1) Milhouse was named after U.S. president Richard Nixon, whose middle name was Milhous.\n21    Action 3: Finish[Richard Nixon]\n22    Question: Which documentary is about Finnish rock groups, Adam Clayton Powell or The Saimaa Gesture?\n23    Action 1: Search[Adam Clayton Powell]\n24    Observation 1: Could not find [Adam Clayton Powell]. Similar: [’Adam Clayton Powell III’, ’Seventh Avenue (Manhattan)’,\n’Adam Clayton Powell Jr. State Office Building’, ’Isabel Washington Powell’, ’Adam Powell’, ’Adam Clayton Powell (film)’,\n’Giancarlo Esposito’].\n25    Action 2: Search[Adam Clayton Powell (film)]\n26    Observation 2: Adam Clayton Powell is a 1989 American documentary film directed by Richard Kilberg. The film is about the\nrise and fall of influential African-American politician Adam Clayton Powell Jr.[3][4] It was later aired as part of the\nPBS series The American Experience.\n27    Action 3: Finish[The Saimaa Gesture]\n28    Question: What profession does Nicholas Ray and Elia Kazan have in common?\n29    Action 1: Search[Nicholas Ray]\n30    Observation 1: Nicholas Ray (born Raymond Nicholas Kienzle Jr., August 7, 1911 { June 16, 1979) was an American film\ndirector, screenwriter, and actor best known for the 1955 film Rebel Without a Cause.\n31    Action 2: Search[Elia Kazan]\n32    Observation 2: Elia Kazan was an American film and theatre director, producer, screenwriter and actor.\n33    Action 3: Finish[director, screenwriter, actor]\n34    Question: Which magazine was started first Arthur’s Magazine or First for Women?\n35    Action 1: Search[Arthur’s Magazine]\n36    Observation 1: Arthur’s Magazine (1844-1846) was an American literary periodical published in Philadelphia in the 19th\ncentury.\n37    Action 2: Search[First for Women]\n38    Observation 2: First for Women is a woman’s magazine published by Bauer Media Group in the USA.[1] The magazine was started\nin 1989.\n39    Action 3: Finish[Arthur’s Magazine]\n40    Question: Were Pavel Urysohn and Leonid Levin known for the same type of work?\n41    Action 1: Search[Pavel Urysohn]\n42    Observation 1: Pavel Samuilovich Urysohn (February 3, 1898\nˆ\na August 17, 1924) was a Soviet mathematician who is best known\nfor his contributions in dimension theory.\n43    Action 2: Search[Leonid Levin]\n44    Observation 2: Leonid Anatolievich Levin is a Soviet-American mathematician and computer scientist.\n45    Action 3: Finish[yes]\nFigure 3: ReAct example prompt for interleaving Thought, Action, Observation steps.\n22",
    "Preprint\n1    Answer the following questions as best you can. You have access to the following tools:\n2    Search: useful for when you need to answer questions about the world\n3    Use the following format:\n4    Question: the input question you must answer\n5    Thought: you should always think about what to do\n6    Action: the action to take, should be one of [Search]\n7    Action Input: the input to the action\n8    Observation: the result of the action\n9    ... (this Thought/Action/Action Input/Observation can repeat N times)\n10    Thought: I now know the final answer\n11    Final Answer: the final answer to the original input question\n12    Begin!\n13    Question:{question}\n14    Thought:\nFigure 4: Langchain ReAct example prompt for interleaving Thought, Action, Observation steps.\n23",
    "Preprint\n1    Given the following extracted parts of a long document and a question, create a final answer with references (\"SOURCES\").\n2    If you don’t know the answer, just say that you don’t know. Don’t try to make up an answer.\n3    ALWAYS return a \"SOURCES\" part in your answer.\n4\n5    QUESTION: Which state/country’s law governs the interpretation of the contract?\n6    =========\n7    Content: This Agreement is governed by English law and the parties submit to the exclusive jurisdiction of the English\ncourts in relation to any dispute (contractual or non-contractual) concerning this Agreement save that either party may\napply to any court for an injunction or other relief to protect its Intellectual Property Rights.\n8    Source: 28-pl\n9    Content: No Waiver. Failure or delay in exercising any right or remedy under this Agreement shall not constitute a waiver\nof such (or any other) right or remedy.\n10    11.7 Severability. The invalidity, illegality or unenforceability of any term (or part of a term) of this Agreement shall\nnot affect the continuation in force of the remainder of the term (if any) and this Agreement.\n11    11.8 No Agency. Except as expressly stated otherwise, nothing in this Agreement shall create an agency, partnership or\njoint venture of any kind between the parties.\n12    11.9 No Third-Party Beneficiaries.\n13    Source: 30-pl\n14    Content:  (b) if Google believes, in good faith, that the Distributor has violated or caused Google to violate any\nAnti-Bribery Laws (as defined in Clause 8.5) or that such a violation is reasonably likely to occur,\n15    Source: 4-pl\n16    =========\n17    FINAL ANSWER: This Agreement is governed by English law.\n18    SOURCES: 28-pl\n19\n20    QUESTION: What did the president say about Michael Jackson?\n21    =========\n22    Content: Madam Speaker, Madam Vice President, our First Lady and Second Gentleman. Members of Congress and the Cabinet.\nJustices of the Supreme Court. My fellow Americans.\n23    Last year COVID-19 kept us apart. This year we are finally together again.\n24    Tonight, we meet as Democrats Republicans and Independents. But most importantly as Americans.\n25    With a duty to one another to the American people to the Constitution.\n26    And with an unwavering resolve that freedom will always triumph over tyranny.\n27    Six days ago, Russia’s Vladimir Putin sought to shake the foundations of the free world thinking he could make it bend to\nhis menacing ways. But he badly miscalculated.\n28    He thought he could roll into Ukraine and the world would roll over. Instead he met a wall of strength he never imagined.\n29    He met the Ukrainian people.\n30    From President Zelenskyy to every Ukrainian, their fearlessness, their courage, their determination, inspires the world.\n31    Groups of citizens blocking tanks with their bodies. Everyone from students to retirees teachers turned soldiers defending\ntheir homeland.\n32    Source: 0-pl\n33    Content: And we won’t stop.\n34    We have lost so much to COVID-19. Time with one another. And worst of all, so much loss of life.\n35    Let’s use this moment to reset. Let’s stop looking at COVID-19 as a partisan dividing line and see it for what it is: A\nGod-awful disease.\n36    Let’s stop seeing each other as enemies, and start seeing each other for who we really are: Fellow Americans.\n37    We can’t change how divided we’ve been. But we can change how we move forward|on COVID-19 and other issues we must face\ntogether.\n38    I recently visited the New York City Police Department days after the funerals of Officer Wilbert Mora and his partner,\nOfficer Jason Rivera.\n39    They were responding to a 9-1-1 call when a man shot and killed them with a stolen gun.\n40    Officer Mora was 27 years old.\n41    Officer Rivera was 22.\n42    Both Dominican Americans who’d grown up on the same streets they later chose to patrol as police officers.\n43    I spoke with their families and told them that we are forever in debt for their sacrifice, and we will carry on their\nmission to restore the trust and safety every community deserves.\n44    Source: 24-pl\n45    Content: And a proud Ukrainian people, who have known 30 years of independence, have repeatedly shown that they will not\ntolerate anyone who tries to take their country backwards.\n46    To all Americans, I will be honest with you, as I’ve always promised. A Russian dictator, invading a foreign country, has\ncosts around the world.\n47    And I’m taking robust action to make sure the pain of our sanctions is targeted at Russia’s economy. And I will use every\ntool at our disposal to protect American businesses and consumers.\n48    Tonight, I can announce that the United States has worked with 30 other countries to release 60 Million barrels of oil\nfrom reserves around the world.\n49    America will lead that effort, releasing 30 Million barrels from our own Strategic Petroleum Reserve. And we stand ready\nto do more if necessary, unified with our allies.\n50    These steps will help blunt gas prices here at home. And I know the news about what’s happening can seem alarming.\n51    But I want you to know that we are going to be okay.\n52    Source: 5-pl\n53    Content: More support for patients and families.\n54    To get there, I call on Congress to fund ARPA-H, the Advanced Research Projects Agency for Health.\n55    It’s based on DARPA|the Defense Department project that led to the Internet, GPS, and so much more.\n56    ARPA-H will have a singular purpose|to drive breakthroughs in cancer, Alzheimer’s, diabetes, and more.\n24",
    "Preprint\n1    A unity agenda for the nation.\n2    We can do this.\n3    My fellow Americans|tonight , we have gathered in a sacred space|the citadel of our democracy.\n4    In this Capitol, generation after generation, Americans have debated great questions amid great strife, and have done\ngreat things.\n5    We have fought for freedom, expanded liberty, defeated totalitarianism and terror.\n6    And built the strongest, freest, and most prosperous nation the world has ever known.\n7    Now is the hour.\n8    Our moment of responsibility.\n9    Our test of resolve and conscience, of history itself.\n10    It is in this moment that our character is formed. Our purpose is found. Our future is forged.\n11    Well I know this nation.\n12    Source: 34-pl\n13    =========\n14    FINAL ANSWER: The president did not mention Michael Jackson.\n15    SOURCES:\n16\n17    QUESTION:{question}\n18    =========\n19{summaries}\n20    =========\n21    FINAL ANSWER:\nFigure 5: Langchain example prompt for QA with sources.\n1    You are a MyScale expert. Given an input question, first create a syntactically correct MyScale query to run, then look\nat the results of the query and return the answer to the input question.\n2    MyScale queries has a vector distance function called DISTANCE(column, array) to compute relevance to the user’s question\nand sort the feature array column by the relevance.\n3    When the query is asking for{topk}closest row, you have to use this distance function to calculate distance to entity’s\narray on vector column and order by the distance to retrieve relevant rows.\n4    *NOTICE*: DISTANCE(column, array) only accept an array column as its first argument and a NeuralArray(entity) as its second\nargument. You also need a user defined function called NeuralArray(entity) to retrieve the entity’s array.\n5    Unless the user specifies in the question a specific number of examples to obtain, query for at most{topk}results using\nthe LIMIT clause as per MyScale. You should only order according to the distance function.\n6    Never query for all columns from a table. You must query only the columns that are needed to answer the question. Wrap\neach column name in double quotes (\") to denote them as delimited identifiers.\n7    Pay attention to use only the column names you can see in the tables below. Be careful to not query for columns that do\nnot exist. Also, pay attention to which column is in which table.\n8    Pay attention to use today() function to get the current date, if the question involves \"today\". ORDER BY clause should\nalways be after WHERE clause. DO NOT add semicolon to the end of SQL. Pay attention to the comment in table schema.\n9\n10    Use the following format:\n11    ======== table info ========\n12{tableinfo}\n13    Question:{input}\n14    SQLQuery:\n15\n16    Here are some examples:\n17    ======== table info ========\n18    CREATE TABLE \"ChatPaper\" (\n19     abstract String,\n20     id String,\n21     vector Array(Float32),\n22    ) ENGINE = ReplicatedReplacingMergeTree()\n23     ORDER BY id\n24     PRIMARY KEY id\n25    Question: What is Feature Pyramid Network?\n26    SQLQuery:    SELECT  ChatPaper.title,   ChatPaper.id,   ChatPaper.authors  FROM  ChatPaper  ORDER  BY  DISTANCE(vector,\nNeuralArray(PaperRank contribution)) LIMIT{topk}\n27\n28    Let’s begin:\n29    ======== table info ========\n30{tableinfo}\n31    Question:{input}\n32    SQLQuery:\nFigure 6: Langchain example prompt for SQL querying using MyScale.\n25",
    "Preprint\n1    A list of documents is shown below. Each document has a number next to it along with a summary of the document. A question\nis also provided.\n2    Respond with the numbers of the documents you should consult to answer the question, in order of relevance, as well as the\nrelevance score.\n3    The relevance score is a number from 1-10 based on how relevant you think the document is to the question.\n4    Do not include any documents that are not relevant to the question.\n5\n6    Example format:\n7    Document 1:\n8    <summary of document 1>\n9\n10    Document 2:\n11    <summary of document 2>\n12\n13    ...\n14\n15    Document 10:\n16    <summary of document 10>\n17\n18    Question: <question>\n19    Answer:\n20    Doc: 9, Relevance: 7\n21    Doc: 3, Relevance: 4\n22    Doc: 7, Relevance: 3\n23\n24    Let’s try this now:\n25{contextstr}\n26    Question:{querystr}\n27    Answer:\nFigure 7:  LlamaIndex example prompt for returning relevant documents and corresponding sum-\nmaries.\n1    You are an IRS chatbot whose primary goal is to help users with filing their tax returns for the 2022 year.\n2    Provide concise replies that are polite and professional.\n3    Answer questions truthfully based on official government information, with consideration to context provided below on\nchanges for 2022 that can affect tax refund.\n4    Do not answer questions that are not related to United States tax procedures and respond with \"I can only help with any\ntax-related questions you may have.\".\n5    If you do not know the answer to a question, respond by saying \\I do not know the answer to your question. You may be able\nto find your answer at www.irs.gov/faqs\"\n6\n7    Changes for 2022 that can affect tax refund:\n8    Changes in the number of dependents, employment or self-employment income and divorce, among other factors, may affect\nyour tax-filing status and refund.  No additional stimulus payments.  Unlike 2020 and 2021, there were no new stimulus\npayments for 2022 so taxpayers should not expect to get an additional payment.\n9    Some tax credits return to 2019 levels.  This means that taxpayers will likely receive a significantly smaller refund\ncompared with the previous tax year. Changes include amounts for the Child Tax Credit (CTC), the Earned Income Tax Credit\n(EITC) and the Child and Dependent Care Credit will revert to pre-COVID levels.\n10    For 2022, the CTC is worth$2,000 for each qualifying child. A child must be under age 17 at the end of 2022 to be a\nqualifying child. For the EITC, eligible taxpayers with no children will get$560 for the 2022 tax year. The Child and\nDependent Care Credit returns to a maximum of$2,100 in 2022.\n11    No above-the-line charitable deductions. During COVID, taxpayers were able to take up to a$600 charitable donation tax\ndeduction on their tax returns. However, for tax year 2022, taxpayers who don’t itemize and who take the standard deduction,\nwon’t be able to deduct their charitable contributions.\n12    More people may be eligible for the Premium Tax Credit. For tax year 2022, taxpayers may qualify for temporarily expanded\neligibility for the premium tax credit.\n13    Eligibility rules changed to claim a tax credit for clean vehicles. Review the changes under the Inflation Reduction Act\nof 2022 to qualify for a Clean Vehicle Credit.\nFigure 8: LlamaIndex example prompt for IRS chatbot guidelines.\n26",
    "Preprint\nDMODULES\nD.1PREDICT\n1class  Predict(dspy.Module):\n2def  __init__(self , signature , ** config):\n3self.signature = dspy.Signature(signature)\n4self.config = config\n5\n6# Module  Parameters.\n7self.lm = dspy.ParameterLM(None) # use  the  default  LM\n8self.demonstrations = dspy.ParameterDemonstrations ([])\n9\n10def  forward(self , ** kwargs):\n11lm = get_the_right_lm(self.lm , kwargs)\n12signature = get_the_right_signature(self.signature , kwargs)\n13demonstrations = get_the_right_demonstrations(self.demonstrations , kwargs)\n14\n15prompt = signature(demos=self.demos , ** kwargs)\n16completions = lm.generate(prompt , **self.config)\n17prediction = Prediction.from_completions(completions , signature=signature)\n18\n19if dsp.settings.compiling  is not  None:\n20trace = dict(predictor=self , inputs=kwargs , outputs=prediction)\n21dspy.settings.traces.append(trace)\n22\n23return  prediction\nD.2CHAIN  OFTHOUGHT\n1class  ChainOfThought(dspy.Module):\n2def  __init__(self , signature):\n3\n4# Modify  signature  from  ‘*inputs  -> *outputs ‘ to  ‘*inputs  -> rationale , *outputs ‘.\n5rationale_field = dspy.OutputField(prefix=\"Reasoning: Let’s think  step by step.\")\n6signature = dspy.Signature(signature).prepend_output_field(rationale_field)\n7\n8# Declare a sub -module  with  the  modified  signature.\n9self.predict = dspy.Predict(self.signature)\n10\n11def  forward(self , ** kwargs):\n12# Just  forward  the  inputs  to the sub -module.\n13return  self.predict (** kwargs)\n27",
    "Preprint\nETELEPROMPTERS\nE.1BOOTSTRAPFEWSHOT\n1class  SimplifiedBootstrapFewShot(Teleprompter):\n2def  __init__(self , metric=None):\n3self.metric = metric\n4\n5def  compile(self , student , trainset , teacher=None):\n6teacher = teacher  if  teacher  is not  None  else  student\n7compiled_program = student.deepcopy ()\n8\n9# Step 1.  Prepare  mappings  between  student  and  teacher  Predict  modules.\n10# Note: other  modules  will  rely on  Predict  internally.\n11assert  student_and_teacher_have_compatible_predict_modules(student , teacher)\n12name2predictor , predictor2name = map_predictors_recursively(student , teacher)\n13\n14# Step 2.  Bootstrap  traces  for  each  Predict  module.\n15# We’ll loop  over  the  training  set. We’ll try  each  example  once  for  simplicity.\n16for  example  in  trainset:\n17if  we_found_enough_bootstrapped_demos (): break\n18\n19# turn on  compiling  mode  which  will  allow  us to keep  track  of the  traces\n20with  dspy.setting.context(compiling=True):\n21# run  the  teacher  program  on the  example , and  get  its  final  prediction\n22# note  that  compiling=True  may  affect  the  internal  behavior  here\n23prediction = teacher (** example.inputs ())\n24\n25# get  the  trace  of the  all  interal  Predict  calls  from  teacher  program\n26predicted_traces = dspy.settings.trace\n27\n28# if the  prediction  is valid , add  the  example  to the  traces\n29if self.metric(example , prediction , predicted_traces):\n30for  predictor , inputs , outputs  in  predicted_traces:\n31d = dspy.Example(automated=True , **inputs , ** outputs)\n32predictor_name = self.predictor2name[id(predictor)]\n33compiled_program[predictor_name ]. demonstrations.append(d)\n34\n35\n36return  compiled_program\nE.2BOOTSTRAPFEWSHOTWITHRANDOMSEARCH\n1class  SimplifiedBootstrapFewShotWithRandomSearch(Teleprompter):\n2def  __init__(self , metric = None , trials =16):\n3self.metric = metric\n4self.trials = trials\n5\n6def  compile(self , student , *, teacher=None , trainset , valset=None):\n7# we can do  forms  of cross -validation  if  valset  is  unset.\n8valset = trainset  if  valset  is None  else  valset\n9\n10candidates = []\n11for  seed in  range(self.trials):\n12# Create a new  basic  bootstrap  few -shot  program.\n13shuffled_trainset = shuffle(trainset , seed=seed)\n14tp = BootstrapFewShot(metric=metric , max_bootstrap_demos=random_size ())\n15candidate_program = tp.compile(student , shuffled_trainset , teacher)\n16\n17# Step 2:  Evaluate  the  generated  candidate  program.\n18score = evaluate_program(candidate_program , self.metric , valset)\n19candidates.append ((score , candidate_program))\n20\n21# return  the  best  candidate  program.\n22return  max(candidates , key=lambda x: x[0]) [1]\n28",
    "Preprint\nE.3BOOTSTRAPFEWSHOTWITHOPTUNA\n1class  SimplifiedBootstrapFewShotWithOptuna(Teleprompter):\n2def  __init__(self , metric , trials =16):\n3self.metric = metric\n4self.trials = trials\n5\n6def  objective(self , trial):\n7pool = self.pool\n8\n9# Step 1:  Create  copy of  student  program.\n10candidate_program = self.student.reset_copy ()\n11\n12# Step 2:  Based  on trial , select  demos  for  each  predictor  in  program.\n13# Note. For  simplicity , we can  just  select a single  demo  for  each  predictor.\n14# But we can  easily  tune  the  number  of  demonstrations  to  select  here.\n15for (name , predictor1), (_, predictor2) in \\\n16zip(pool.named_predictors (), candidate_program.named_predictors ()):\n17all_demos = predictor1.demos\n18demo_index = trial.suggest_int(f\"demo_index_for_{name}\", 0, len(all_demos) - 1)\n19predictor2.demos = [all_demos[demo_index ]]\n20\n21# Step 3:  Evaluate  the  modified  candidate  program.\n22score = evaluate_program(candidate_program , self.metric , self.valset)\n23\n24# Step 4:  Store  the  candidate  for  Optuna  to  select  highest -scoring  program.\n25trial.set_user_attr(\"program\", candidate_program)\n26return  score\n27\n28def  compile(self , student , trainset , teacher=None , valset=None):\n29self.trainset = trainset\n30self.valset = trainset  if  valset  is None  else  valset\n31\n32self.student = student.deepcopy ()\n33self.teacher = teacher.deepcopy () if  teacher  else  student.deepcopy ()\n34\n35# Leverage  BootstrapFewshot  to  create a large  number  of  potential  demonstrations.\n36tp = BootstrapFewShot ()\n37self.pool = tp.compile(self.student , self.teacher , self.trainset , self.metric)\n38\n39# Use  Optuna  to find  the  best  program  by  optimizing  the  objective  function.\n40best_program = optimize_with_optuna(self.objective)\n41\n42print(’Best  score:’, best_program.score)\n43print(’Best  program:’, best_program)\n44return  best_program\n29",
    "Preprint\nFEXAMPLES OF THE PROMPTS AUTOMATICALLY GENERATED BYDSPY\nFor GSM8K, we include the prompt bootstrapped by DSPy for GSM8Kllama2-13b-chatfor the\nvanilla program compiled withbootstrap×2in Figure 9.\nWe also include a CoT prompt for GSM8K and ageneratequeryprompt from the multihop pro-\ngram for HotPotQA. All of these, particularly their demonstrations’ labels and their selection, are\ngenerated by DSPy automatically usingllama2-13b-chat.\n30",
    "Preprint\n1    Given the fields ‘question‘, produce the fields ‘answer‘.\n2\n3    ---\n4\n5    Follow the following format.\n6\n7    Question:${question}\n8    Answer:${answer}\n9\n10    ---\n11\n12    Question: Jimmy and Irene go shopping for clothes on a Tuesday, where senior citizens get a 10% discount on their purchases.\nJimmy picks out 3 shorts from the$15 rack. Irene grabs 5 shirts from the$17 rack. How much money do they give to the\ncashier?\n13    Answer: Jimmy picks out 3 shorts at$15 each =$45. Irene grabs 5 shirts at$17 each =$85. Total cost =$45 +$85 =$130.\nSince senior citizens get a 10% discount, they will pay 10% of$130 =$13. So, they will give the cashier$130 -$13 =\n$117. ---\n14\n15    ---\n16\n17    Question:\nFigure  9:   Copy  of  the  prompt  automatically  generated  by  DSPy  for  GSM8K  Llama2-13b-chat\nvanilla program compiled withbootstrap×2.\n1    Given the fields ‘question‘, produce the fields ‘answer‘.\n2\n3    ---\n4\n5    Follow the following format.\n6\n7    Question:${question}\n8    Reasoning: Let’s think step by step in order to$produce the answer. We ...\n9    Answer:${answer}\n10\n11    ---\n12\n13    Question: Mark is baking bread. He has to let it rise for 120 minutes twice. He also needs to spend 10 minutes kneading\nit and 30 minutes baking it. How many minutes does it take Mark to finish making the bread?\n14    Reasoning: Let’s think step by step in order to find out how many minutes it takes Mark to finish making the bread. We know\nthat he needs to let it rise for 120 minutes twice, so that’s 240 minutes. Then, he needs to spend 10 minutes kneading it\nand 30 minutes baking it. So, in total, it will take Mark 240 + 10 + 30 = 280 minutes to finish making the bread.\n15    Answer: 280 ---\n16\n17    ---\n18\n19    Question: Ben has$2000 for his business operations costs. He orders goods from his supplier and writes them a cheque for\n$600. His debtor pays him$800 from the purchases they had made on credit. Mr. Ben then decides to do equipment maintenance\nand spends$1200 on the whole operation. How much money is Mr. Ben remaining with?\n20    Reasoning: Let’s think step by step in order to find out how much money Mr. Ben is remaining with. We know that he had\n$2000 to begin with, and he spent$600 on goods from his supplier, so he has$2000 -$600 =$1400 left. Then, his debtor\npaid him$800, so he has$1400 +$800 =$2200. Finally, he spent$1200 on equipment maintenance, so he has$2200 -$1200\n=$1000 left.\n21    Answer:$1000 ---\n22\n23    ---\n24\n25    ... several other demonstrations here ...\n26\n27    ---\n28\n29    Question:\nFigure 10:  Shortened copy of the prompt automatically generated by DSPy for GSM8K Llama2-\n13b-chat CoT program compiled withbootstrap.\n31",
    "Preprint\n1    Given the fields ‘context‘, ‘question‘, produce the fields ‘searchquery‘.\n2\n3    ---\n4\n5    Follow the following format.\n6\n7    Context:${context}\n8    Question:${question}\n9    Reasoning: Let’s think step by step in order to${produce the searchquery}. We ...\n10    Search Query:${searchquery}\n11\n12    ---\n13\n14    Context:\n15    [1] Twilight (novel series) | Twilight is a series of four vampire-themed fantasy romance novels by American author\nStephenie Meyer. ...\n16    [2] Harper Connelly Mysteries | The Harper Connelly Mysteries is a series of fantasy mystery novels written by Charlaine\nHarris, and first published in 2005. ...\n17    [3] The Dark Heroine | The Dark Heroine is a series of vampire-themed fantasy romance novels written by English author\nAbigail Gibbs, published by HarperCollins in 2012. ...\n18\n19    Question:  In which year was the first of the vampire-themed fantasy romance novels for which The Twilight Saga:  The\nOfficial Illustrated Guide serves as a spin-off encyclopedic reference book first published?\n20\n21    Reasoning: Let’s think step by step in order to determine the year the first of the vampire-themed fantasy romance novels\nwas first published. ...\n22\n23    Search Query: When was the first of the vampire-themed fantasy romance novels published?\n24\n25    ---\n26\n27    Context:\n28    [1] The Victorians | The Victorians - Their Story In Pictures is a 2009 British documentary series which focuses on\nVictorian art and culture. ...\n29    [2] The Caxtons | The Caxtons: A Family Picture is an 1849 Victorian novel by Edward Bulwer-Lytton that was popular in its\ntime.\n30    [3] Victorian (comics) | The Victorian is a 25-issue comic book series published by Penny-Farthing Press and starting in\n1999. ...\n31\n32    Question: The Victorians - Their Story In Pictures is a documentary series written by an author born in what year?\n33\n34    Reasoning: Let’s think step by step in order to produce the search query. We know that the documentary series is about\nVictorian art and culture, and it was written and presented by Jeremy Paxman. Therefore, we need to find the year in which\nJeremy Paxman was born.\n35\n36    Search Query: Jeremy Paxman birth year\n37\n38    ---\n39\n40\n41    Context:\nFigure 11: Shortened copy of the prompt automatically generated by DSPy for HotPotQA Llama2-\n13b-chat multi-hop program (generating second hop query) compiled withbootstrap.\n32"
  ]
}